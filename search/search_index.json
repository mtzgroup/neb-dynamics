{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neb Dynamics","text":""},{"location":"#install","title":"Install","text":"<ol> <li><code>pip install \"git+https://github.com/mtzgroup/neb-dynamics.git\"</code></li> </ol>"},{"location":"#maintainers","title":"Maintainers","text":"<p>If you have any questions, please ask: Jan</p>"},{"location":"#tips","title":"Tips","text":"<ul> <li>If using XTB, setting <code>OMP_NUM_THREADS=1</code> can speed up the process when the individual calculation will not benefit from paralellization.</li> </ul>"},{"location":"Tutorial/","title":"Tutorial","text":"<p>This tutorial references ChainInputs, NEBInputs,Chain, Trajectory, TDStructure, NEB and VelocityProjectedOptimizer</p>"},{"location":"Tutorial/#running-neb-using-terachem-in-chemcloud","title":"Running NEB using TeraChem in ChemCloud","text":"<pre><code># Running our first NEB calculation. Naturally, we are going to calculate a pi-bond torsion.\n\n# # 1. Create initial guess\n#\n# ### We will create endpoints as we did the previous tutorials.\n\nfrom neb_dynamics.tdstructure import TDStructure\nfrom neb_dynamics.trajectory import Trajectory\n\nstart = TDStructure.from_smiles(\"C=C\")\nend = start.copy()\n\n# we can also load in a structure from a file path with:\n# start = TDStructure.from_xyz(\"/path/to/file.xyz\")\nend_coords = end.coords\nend_coords_swapped = end_coords[[0,1,3,2,4,5],:] # We have swapped the indices of two hydrogens\nend = end.update_coords(end_coords_swapped)\n# we can also load in a structure from a file path with:\n# end = TDStructure.from_xyz(\"/path/to/file.xyz\")\n\n# ### Now we need to optimize them to our desired level of theory\n\nstart_opt = start.xtb_geom_optimization()\n# start_opt = start.tc_geom_optimization() # use this one if you want to run TeraChem in ChemCloud\nend_opt = end.xtb_geom_optimization()\n# end_opt = end.tc_geom_optimization() # use this one if you want to run TeraChem in ChemCloud\n\n# ### Now we need to interpolate between our endpoints\n\ntr = Trajectory([start_opt, end_opt]).run_geodesic(nimages=10)\n\n# ### Finally, let's create our Chain object\n\nfrom neb_dynamics.Chain import Chain\nfrom neb_dynamics.Inputs import ChainInputs\n\ncni = ChainInputs(k=0.1, delta_k=0.09)\ninitial_chain = Chain.from_traj(tr, parameters=cni)\n\n# # 2. Let's set up our NEB optimization\n\nfrom neb_dynamics.NEB import NEB\nfrom neb_dynamics.Inputs import NEBInputs\n\n# NEB\n\n# The NEB object takes in 3 parameters:\n# * initial_chain: our initial guess chain object to optimize\n# * parameters: an NEBInputs object containing the parameters for NEB optimization and convergence\n# * optimizer: the optimizer to use. We suggest you use `VelocityProjectedOptimizer` from\n#             `neb_dynamics.optimizer.VPO`\n\nnbi = NEBInputs(v=True, tol=0.0001, ts_spring_thre=0.0001, climb=True)\n\nfrom neb_dynamics.optimizers.VPO import VelocityProjectedOptimizer\n\nopt = VelocityProjectedOptimizer(timestep=0.5)\n\nn = NEB(initial_chain=initial_chain, parameters=nbi, optimizer=opt)\n\n_ = n.optimize_chain()\n\nn.plot_opt_history(1)\n\nprint(n.optimized.get_ts_guess().coords)\n</code></pre>"},{"location":"elementarystep/","title":"Elementarystep","text":"<p>this whole module needs to be revamped and integrated with the qcio results objects probably.</p>"},{"location":"elementarystep/#neb_dynamics.elementarystep.ConcavityResults","title":"<code>ConcavityResults</code>  <code>dataclass</code>","text":"<p>Stores results on concavity checks (i.e. whether chain has a \"dip\" that could be        a new minimum)</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass ConcavityResults:\n    \"\"\"\n    Stores results on concavity checks (i.e. whether chain has a \"dip\" that could be\\\n        a new minimum)\n    \"\"\"\n    is_concave: bool\n    minimization_results: list[Node]\n    number_grad_calls: int\n\n    @property\n    def is_not_concave(self):\n        return not self.is_concave\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.ElemStepResults","title":"<code>ElemStepResults</code>  <code>dataclass</code>","text":"<p>Object to build report on minimization from elementary step checks.</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass ElemStepResults:\n    \"\"\"\n    Object to build report on minimization from elementary step checks.\n    \"\"\"\n    is_elem_step: bool\n    is_concave: bool\n    splitting_criterion: str\n    minimization_results: List[Node]\n    number_grad_calls: int\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.IRCResults","title":"<code>IRCResults</code>  <code>dataclass</code>","text":"<p>Stores results on (pseudo)IRC checks</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass IRCResults:\n    \"\"\"Stores results on (pseudo)IRC checks\n    \"\"\"\n    found_reactant: Node\n    found_product: Node\n    number_grad_calls: int\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.check_if_elem_step","title":"<code>check_if_elem_step(inp_chain)</code>","text":"<p>Calculates whether an input chain is an elementary step.</p> <p>Parameters:</p> Name Type Description Default <code>inp_chain</code> <code>Chain</code> <p>input chain to check.</p> required <p>Returns:</p> Name Type Description <code>ElemStepResults</code> <code>ElemStepResults</code> <p>object containing report on chain.</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>def check_if_elem_step(inp_chain: Chain) -&gt; ElemStepResults:\n    \"\"\"Calculates whether an input chain is an elementary step.\n\n    Args:\n        inp_chain (Chain): input chain to check.\n\n    Returns:\n        ElemStepResults: object containing report on chain.\n    \"\"\"\n    n_geom_opt_grad_calls = 0\n    chain = inp_chain.copy()\n    if len(inp_chain) &lt;= 1:\n        return ElemStepResults(\n            is_elem_step=True,\n            is_concave=True,\n            splitting_criterion=None,\n            minimization_results=None,\n            number_grad_calls=0\n        )\n\n    concavity_results = _chain_is_concave(inp_chain)\n    n_geom_opt_grad_calls += concavity_results.number_grad_calls\n\n    if concavity_results.is_not_concave:\n        return ElemStepResults(\n            is_elem_step=False,\n            is_concave=concavity_results.is_concave,\n            splitting_criterion='minima',\n            minimization_results=concavity_results.minimization_results,\n            number_grad_calls=n_geom_opt_grad_calls\n        )\n\n    crude_irc_passed, ngc_approx_elem_step = is_approx_elem_step(\n        chain=inp_chain)\n    n_geom_opt_grad_calls += ngc_approx_elem_step\n\n    if crude_irc_passed:\n        return ElemStepResults(\n            is_elem_step=True,\n            is_concave=concavity_results.is_concave,\n            splitting_criterion=None,\n            minimization_results=[inp_chain[0], inp_chain[-1]],\n            number_grad_calls=n_geom_opt_grad_calls\n        )\n\n    pseu_irc_results = pseudo_irc(chain=inp_chain)\n    n_geom_opt_grad_calls += pseu_irc_results.number_grad_calls\n\n    found_r = pseu_irc_results.found_reactant.is_identical(chain[0])\n    found_p = pseu_irc_results.found_product.is_identical(chain[-1])\n    minimizing_gives_endpoints = found_r and found_p\n\n    elem_step = True if minimizing_gives_endpoints else False\n\n    return ElemStepResults(is_elem_step=elem_step,\n                           is_concave=concavity_results.is_concave,\n                           splitting_criterion='maxima',\n                           minimization_results=[pseu_irc_results.found_reactant, pseu_irc_results.found_product],\n                           number_grad_calls=n_geom_opt_grad_calls\n                           )\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.is_approx_elem_step","title":"<code>is_approx_elem_step(chain, slope_thresh=0.1)</code>","text":"<p>Will do at most 50 steepest descent steps  on geometries neighboring the transition state guess and check whether they are approaching the chain endpoints. If function returns False, the geoms will be fully optimized.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>chain to check on</p> required <code>slope_thresh</code> <code>float</code> <p>Steepest descent optimization will stop when the slope</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>Tuple[bool, int]</code> <p>whether chain seems to be an elementary step</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>def is_approx_elem_step(chain: Chain, slope_thresh=0.1) -&gt; Tuple[bool, int]:\n    \"\"\"Will do at most 50 steepest descent steps  on geometries neighboring the transition state guess\n    and check whether they are approaching the chain endpoints. If function returns False, the geoms\n    will be fully optimized.\n\n    Args:\n        chain (Chain): chain to check on\n        slope_thresh (float, optional): Steepest descent optimization will stop when the slope\n        of the distances of the minimized geometry to the target endpoint is &gt;= threshold.\n        Defaults to 0.1.\n\n    Returns:\n        bool: whether chain seems to be an elementary step\n    \"\"\"\n    if chain.energies_are_monotonic:\n        return True\n\n    arg_max = np.argmax(chain.energies)\n\n    r_passes_opt, r_traj = _converges_to_an_endpoints(chain=chain, node_index=(arg_max - 1), direction=-1,\n                                                      slope_thresh=slope_thresh)\n    p_passes_opt, p_traj = _converges_to_an_endpoints(chain=chain, node_index=(arg_max + 1), direction=+1,\n                                                      slope_thresh=slope_thresh)\n\n    r_passes = r_passes_opt and r_traj[-1]._is_connectivity_identical(chain[0])\n    p_passes = p_passes_opt and p_traj[-1]._is_connectivity_identical(\n        chain[-1])\n\n    n_grad_calls = len(r_traj) + len(p_traj)\n    if r_passes and p_passes:\n        return True, n_grad_calls\n    else:\n        return False, n_grad_calls\n</code></pre>"},{"location":"inputs/","title":"Inputs","text":""},{"location":"inputs/#neb_dynamics.Inputs.ChainInputs","title":"<code>ChainInputs</code>  <code>dataclass</code>","text":"<p>Object containing parameters relevant to chain. <code>k</code>: maximum spring constant. <code>delta_k</code>: parameter to use for calculating energy weighted spring constants         see: https://pubs.acs.org/doi/full/10.1021/acs.jctc.1c00462</p> <p><code>node_class</code>: type of node to use <code>do_parallel</code>: whether to compute gradients and energies in parallel <code>use_geodesic_interpolation</code>: whether to use GI in interpolations <code>friction_optimal_gi</code>: whether to optimize 'friction' parameter when running GI</p> <p><code>do_chain_biasing</code>: whether to use chain biasing (Under Development, not ready for use) <code>cb</code>: Chain biaser object (Under Development, not ready for use)</p> <p><code>node_freezing</code>: whether to freeze nodes in NEB convergence <code>node_conf_en_thre</code>: float = threshold for energy difference (kcal/mol) of geometries                         for identifying identical conformers</p> <p><code>tc_model_method</code>: 'method' parameter for electronic structure calculations <code>tc_model_basis</code>: 'method' parameter for electronic structure calculations <code>tc_kwds</code>: keyword arguments for electronic structure calculations</p> Source code in <code>neb_dynamics/Inputs.py</code> <pre><code>@dataclass\nclass ChainInputs:\n    \"\"\"\n    Object containing parameters relevant to chain.\n    `k`: maximum spring constant.\n    `delta_k`: parameter to use for calculating energy weighted spring constants\n            see: https://pubs.acs.org/doi/full/10.1021/acs.jctc.1c00462\n\n    `node_class`: type of node to use\n    `do_parallel`: whether to compute gradients and energies in parallel\n    `use_geodesic_interpolation`: whether to use GI in interpolations\n    `friction_optimal_gi`: whether to optimize 'friction' parameter when running GI\n\n    `do_chain_biasing`: whether to use chain biasing (Under Development, not ready for use)\n    `cb`: Chain biaser object (Under Development, not ready for use)\n\n    `node_freezing`: whether to freeze nodes in NEB convergence\n    `node_conf_en_thre`: float = threshold for energy difference (kcal/mol) of geometries\n                            for identifying identical conformers\n\n    `tc_model_method`: 'method' parameter for electronic structure calculations\n    `tc_model_basis`: 'method' parameter for electronic structure calculations\n    `tc_kwds`: keyword arguments for electronic structure calculations\n    \"\"\"\n    k: float = 0.1\n    delta_k: float = 0.0\n\n    node_class: Node = Node3D\n    do_parallel: bool = True\n    use_geodesic_interpolation: bool = True\n    friction_optimal_gi: bool = True\n\n    do_chain_biasing: bool = False\n    cb: ChainBiaser = None\n\n    node_freezing: bool = True\n    node_conf_en_thre: float = 0.5  # kcal/mol\n\n    tc_model_method: str = \"b3lyp\"\n    tc_model_basis: str = \"6-31g\"\n    tc_kwds: dict = field(default_factory=dict)\n\n    def __post_init__(self):\n        if self.do_chain_biasing and self.cb is None:\n            raise ValueError(\n                \"No chain biaser was inputted. Fix this or set 'do_chain_biasing' to False.\"\n            )\n\n    def copy(self):\n        return ChainInputs(**self.__dict__)\n</code></pre>"},{"location":"inputs/#neb_dynamics.Inputs.GIInputs","title":"<code>GIInputs</code>  <code>dataclass</code>","text":"<p>Inputs for geodesic interpolation. See         geodesic interpolation             for details.</p> <p><code>nimages</code>: number of images to use (default: 15)</p> <p><code>friction</code>: value for friction parameter. influences the penalty for         pairwise distances becoming too large. (default: 0.01)</p> <p><code>nudge</code>: value for nudge parameter. (default: 0.001)</p> <p><code>extra_kwds</code>: dictionary containing other keywords geodesic interpolation might use.</p> Source code in <code>neb_dynamics/Inputs.py</code> <pre><code>@dataclass\nclass GIInputs:\n    \"\"\"\n    Inputs for geodesic interpolation. See \\\n        [geodesic interpolation](https://pubs.aip.org/aip/jcp/article/150/16/164103/198363/Geodesic-interpolation-for-reaction-pathways) \\\n            for details.\n\n    `nimages`: number of images to use (default: 15)\n\n    `friction`: value for friction parameter. influences the penalty for \\\n        pairwise distances becoming too large. (default: 0.01)\n\n    `nudge`: value for nudge parameter. (default: 0.001)\n\n    `extra_kwds`: dictionary containing other keywords geodesic interpolation might use.\n    \"\"\"\n    nimages: int = 15\n    friction: float = 0.01\n    nudge: float = 0.001\n    extra_kwds: dict = field(default_factory=dict)\n</code></pre>"},{"location":"inputs/#neb_dynamics.Inputs.NEBInputs","title":"<code>NEBInputs</code>  <code>dataclass</code>","text":"<p>Object containing inputs relating to NEB convergence. <code>tol</code>: tolerace for optimizations (Hartrees)</p> <p><code>climb</code>: whether to use climbing image NEB</p> <p><code>en_thre</code>: energy difference threshold. (default: tol/450)</p> <p><code>rms_grad_thre</code>: RMS of perpendicular gradient threhsold (default: tol)</p> <p><code>max_rms_grad_thre</code>: maximum(RMS) of perpedicular gradients threshold (default: tol*2.5)</p> <p><code>ts_grad_thre</code>= infinity norm of TS node threshold (default: tol*2.5)</p> <p><code>ts_spring_thre</code>= infinity norm of spring forces of triplet around TS node (default: tol * 1.5),</p> <p><code>skip_identical_graphs</code>: whether to skip minimizations where endpoints have identical graphs</p> <p><code>early_stop_force_thre</code>: infinity norm of TS node early stop check threshold (default: 0.0 | i.e. no early stop check)</p> <p><code>negative_steps_thre</code>: number of steps chain can oscillate until the step size is halved (default: 10)</p> <p><code>max_steps</code>: maximum number of NEB steps allowed (default: 1000)</p> <p><code>v</code>: whether to be verbose (default: True)</p> <p><code>preopt_with_xtb</code>: whether to preconverge a chain using XTB (default: False)</p> Source code in <code>neb_dynamics/Inputs.py</code> <pre><code>@dataclass\nclass NEBInputs:\n    \"\"\"\n    Object containing inputs relating to NEB convergence.\n    `tol`: tolerace for optimizations (Hartrees)\n\n    `climb`: whether to use climbing image NEB\n\n    `en_thre`: energy difference threshold. (default: tol/450)\n\n    `rms_grad_thre`: RMS of perpendicular gradient threhsold (default: tol)\n\n    `max_rms_grad_thre`: maximum(RMS) of perpedicular gradients threshold (default: tol*2.5)\n\n    `ts_grad_thre`= infinity norm of TS node threshold (default: tol*2.5)\n\n    `ts_spring_thre`= infinity norm of spring forces of triplet around TS node (default: tol * 1.5),\n\n    `skip_identical_graphs`: whether to skip minimizations where endpoints have identical graphs\n\n    `early_stop_force_thre`: infinity norm of TS node early stop check threshold (default: 0.0 | i.e. no early stop check)\n\n    `negative_steps_thre`: number of steps chain can oscillate until the step size is halved (default: 10)\n\n    `max_steps`: maximum number of NEB steps allowed (default: 1000)\n\n    `v`: whether to be verbose (default: True)\n\n    `preopt_with_xtb`: whether to preconverge a chain using XTB (default: False)\n    \"\"\"\n    tol: float = 0.001 * BOHR_TO_ANGSTROMS\n    climb: bool = False\n    en_thre: float = None\n    rms_grad_thre: float = None\n    max_rms_grad_thre: float = None\n    skip_identical_graphs: bool = True\n\n    grad_thre: float = None\n    ts_grad_thre: float = None\n    ts_spring_thre: float = None\n    barrier_thre: float = 0.1  # kcal/mol\n\n    early_stop_force_thre: float = 0.0\n    early_stop_chain_rms_thre: float = 0.0\n    early_stop_corr_thre: float = 10.0\n    early_stop_still_steps_thre: int = 100\n\n    negative_steps_thre: int = 10\n\n    max_steps: float = 1000\n\n    v: bool = False\n\n    preopt_with_xtb: bool = False\n\n    def __post_init__(self):\n        if self.en_thre is None:\n            self.en_thre = self.tol / 450\n\n        if self.rms_grad_thre is None:\n            self.rms_grad_thre = self.tol\n\n        if self.grad_thre is None:\n            self.grad_thre = self.tol / 2\n\n        if self.ts_grad_thre is None:\n            self.ts_grad_thre = self.tol * 5/2\n\n        if self.ts_spring_thre is None:\n            self.ts_spring_thre = self.tol * 5/2\n\n        if self.max_rms_grad_thre is None:\n            self.max_rms_grad_thre = self.tol * 5/2\n\n    def copy(self):\n        return NEBInputs(**self.__dict__)\n</code></pre>"},{"location":"neb/","title":"Neb","text":"<p>Class for running, storing, and visualizing nudged elastic band minimizations. Main functions to use are: - self.optimize_chain() - self.plot_opt_history()</p> <p>Note</p> <p>Colton said this rocks</p> Source code in <code>neb_dynamics/NEB.py</code> <pre><code>@dataclass\nclass NEB:\n    \"\"\"\n    Class for running, storing, and visualizing nudged elastic band minimizations.\n    Main functions to use are:\n    - self.optimize_chain()\n    - self.plot_opt_history()\n\n    !!! Note\n        Colton said this rocks\n\n    \"\"\"\n    initial_chain: Chain\n    parameters: NEBInputs\n    optimizer: Optimizer\n\n    optimized: Chain = None\n    chain_trajectory: list[Chain] = field(default_factory=list)\n    gradient_trajectory: list[np.array] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.n_steps_still_chain = 0\n        self.grad_calls_made = 0\n        self.geom_grad_calls_made = 0\n\n    def _reset_node_convergence(self, chain) -&gt; None:\n        for node in chain:\n            node.converged = False\n\n    def set_climbing_nodes(self, chain: Chain) -&gt; None:\n        \"\"\"Iterates through chain and sets the nodes that should climb.\n\n        Args:\n            chain: chain to set inputs for\n        \"\"\"\n        if self.parameters.climb:\n            inds_maxima = [chain.energies.argmax()]\n\n            if self.parameters.v &gt; 0:\n                print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n            for ind in inds_maxima:\n                chain[ind].do_climb = True\n\n    def _do_early_stop_check(self, chain: Chain) -&gt; Tuple[bool, ElemStepResults]:\n        \"\"\"\n        this function calls geometry minimizations to verify if\n        chain is an elementary step\n\n        Args:\n            chain (Chain): chain to check\n\n        Returns:\n            tuple(boolean, ElemStepResults) : boolean of whether\n                    to stop early, and an ElemStepResults objects\n        \"\"\"\n\n        elem_step_results = check_if_elem_step(chain)\n\n        if not elem_step_results.is_elem_step:\n            print(\"\\nStopped early because chain is not an elementary step.\")\n            print(\n                f\"Split chain based on: {elem_step_results.splitting_criterion}\")\n            self.optimized = chain\n            return True, elem_step_results\n\n        else:\n            self.n_steps_still_chain = 0\n            return False, elem_step_results\n\n    def _check_early_stop(self, chain: Chain):\n        \"\"\"\n        this function computes chain distances and checks gradient\n        values in order to decide whether the expensive minimization of\n        the chain should be done.\n        \"\"\"\n        ind_ts_guess = np.argmax(chain.energies)\n        ts_guess_grad = np.amax(np.abs(chain.get_g_perps()[ind_ts_guess]))\n\n        if ts_guess_grad &lt;= self.parameters.early_stop_force_thre:\n\n            new_params = self.parameters.copy()\n            new_params.early_stop_force_thre = 0.0\n            self.parameters = new_params\n\n            # going to set climbing nodes when checking early stop\n            if self.parameters.climb:\n                self.set_climbing_nodes(chain=chain)\n                self.parameters.climb = False  # no need to set climbing nodes again\n\n            stop_early, elem_step_results = self._do_early_stop_check(\n                chain)\n            return stop_early, elem_step_results\n\n        else:\n            return False, ElemStepResults(is_elem_step=None,\n                                          is_concave=None,\n                                          splitting_criterion=None,\n                                          minimization_results=[],\n                                          number_grad_calls=0)\n\n    # @Jan: This should be a more general function so that the\n    # lower level of theory can be whatever the user wants.\n    def _do_xtb_preopt(self, chain) -&gt; Chain:  #\n        \"\"\"\n        This function will loosely minimize an input chain using the GFN2-XTB method,\n        then return a new chain which can be used as an initial guess for a higher\n        level of theory calculation\n        \"\"\"\n\n        xtb_params = chain.parameters.copy()\n        xtb_params.node_class = Node3D\n        chain_traj = chain.to_trajectory()\n        xtb_chain = Chain.from_traj(chain_traj, parameters=xtb_params)\n        xtb_nbi = NEBInputs(tol=self.parameters.tol*10,\n                            v=True, preopt_with_xtb=False, max_steps=1000)\n\n        opt_xtb = VelocityProjectedOptimizer(timestep=1)\n        n = NEB(initial_chain=xtb_chain, parameters=xtb_nbi, optimizer=opt_xtb)\n        try:\n            _ = n.optimize_chain()\n            print(\n                f\"\\nConverged an xtb chain in {len(n.chain_trajectory)} steps\")\n        except Exception:\n            print(\n                f\"\\nCompleted {len(n.chain_trajectory)} xtb steps. Did not converge.\")\n\n        xtb_seed_tr = n.chain_trajectory[-1].to_trajectory()\n        xtb_seed_tr.update_tc_parameters(chain[0].tdstructure)\n\n        xtb_seed = Chain.from_traj(\n            xtb_seed_tr, parameters=chain.parameters.copy())\n        xtb_seed.gradients  # calling it to cache the values\n\n        return xtb_seed\n\n    def optimize_chain(self) -&gt; ElemStepResults:\n        \"\"\"\n        Main function. After an NEB object has been created, running this function will\n        minimize the chain and return the elementary step results from the final minimized chain.\n\n        Running this function will populate the `.chain_trajectory` object variable, which\n        contains the history of the chains minimized. Once it is completed, you can use\n        `.plot_opt_history()` to view the optimization over time.\n\n        Args:\n            self: initialized NEB object\n        Raises:\n            NoneConvergedException: If chain did not converge in alloted steps.\n        \"\"\"\n\n        nsteps = 1\n        nsteps_negative_grad_corr = 0\n\n        if self.parameters.preopt_with_xtb:\n            chain_previous = self._do_xtb_preopt(self.initial_chain)\n            self.chain_trajectory.append(chain_previous)\n\n            stop_early, elem_step_results = self._do_early_stop_check(\n                chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n        else:\n            chain_previous = self.initial_chain.copy()\n            self.chain_trajectory.append(chain_previous)\n        chain_previous._zero_velocity()\n\n        while nsteps &lt; self.parameters.max_steps + 1:\n            if nsteps &gt; 1:\n                stop_early, elem_step_results = self._check_early_stop(\n                    chain_previous)\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                if stop_early:\n                    return elem_step_results\n\n            new_chain = self.update_chain(chain=chain_previous)\n            max_rms_grad_val = np.amax(new_chain.rms_gperps)\n            ind_ts_guess = np.argmax(new_chain.energies)\n            ts_guess_grad = np.amax(\n                np.abs(new_chain.get_g_perps()[ind_ts_guess]))\n            converged = chain_converged(\n                chain_prev=chain_previous, chain_new=new_chain,\n                parameters=self.parameters)\n            if converged and self.parameters.v:\n                print(\"\\nConverged!\")\n\n            n_nodes_frozen = 0\n            for node in new_chain:\n                if node.converged:\n                    n_nodes_frozen += 1\n\n            grad_calls_made = len(new_chain) - n_nodes_frozen\n            self.grad_calls_made += grad_calls_made\n\n            grad_corr = new_chain._gradient_correlation(chain_previous)\n            if grad_corr &lt; 0:\n                nsteps_negative_grad_corr += 1\n            else:\n                nsteps_negative_grad_corr = 0\n\n            if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n                print(\"\\nstep size causing oscillations. decreasing by 50%\")\n                self.optimizer.timestep *= 0.5\n                nsteps_negative_grad_corr = 0\n\n            if self.parameters.v:\n\n                print(\n                    f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                        max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                            {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                                  {n_nodes_frozen} // {grad_corr}{' '*20}\", end=\"\\r\"\n                )\n                sys.stdout.flush()\n\n            self.chain_trajectory.append(new_chain)\n            self.gradient_trajectory.append(new_chain.gradients)\n\n            if converged:\n                if self.parameters.v:\n                    print(\"\\nChain converged!\")\n\n                elem_step_results = check_if_elem_step(new_chain)\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                self.optimized = new_chain\n                return elem_step_results\n\n            chain_previous = new_chain\n            nsteps += 1\n\n        new_chain = self.update_chain(chain=chain_previous)\n        if not chain_converged(chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters):\n            raise NoneConvergedException(\n                trajectory=self.chain_trajectory,\n                msg=f\"\\nChain did not converge at step {nsteps}\",\n                obj=self,\n            )\n\n    def update_chain(self, chain: Chain) -&gt; Chain:\n        grad_step = chain.gradients\n        new_chain = self.optimizer.optimize_step(\n            chain=chain, chain_gradients=grad_step)\n        return new_chain\n\n    def write_to_disk(self, fp: Path, write_history=True):\n        # write output chain\n        self.chain_trajectory[-1].write_to_disk(fp)\n\n        if write_history:\n            out_folder = fp.resolve().parent / (fp.stem + \"_history\")\n\n            if out_folder.exists():\n                shutil.rmtree(out_folder)\n\n            if not out_folder.exists():\n                out_folder.mkdir()\n\n            for i, chain in enumerate(self.chain_trajectory):\n                fp = out_folder / f\"traj_{i}.xyz\"\n                chain.write_to_disk(fp)\n\n    def plot_chain_distances(self):\n        distances = _calculate_chain_distances(self.chain_trajectory)\n\n        fs = 18\n        s = 8\n\n        f, ax = plt.subplots(figsize=(1.16*s, s))\n\n        plt.plot(distances, 'o-')\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylabel(\"Distance to previous chain\", fontsize=fs)\n        plt.xlabel(\"Chain id\", fontsize=fs)\n\n        plt.show()\n\n    def plot_grad_delta_mag_history(self):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i-1]\n            projs.append(prev_chain._gradient_delta_mags(chain))\n\n        plt.plot(projs)\n        plt.ylabel(\"NEB |\u2206gradient|\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        # plt.ylim(0,1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_projector_history(self, var='gradients'):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i-1]\n            if var == 'gradients':\n                projs.append(prev_chain._gradient_correlation(chain))\n            elif var == 'tangents':\n                projs.append(prev_chain._tangent_correlations(chain))\n            else:\n                raise ValueError(f\"Unrecognized var: {var}\")\n        plt.plot(projs)\n        plt.ylabel(f\"NEB {var} correlation\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylim(-1.1, 1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_opt_history(self, do_3d=False):\n\n        s = 8\n        fs = 18\n\n        if do_3d:\n            all_chains = self.chain_trajectory\n\n            ens = np.array([c.energies-c.energies[0] for c in all_chains])\n            all_integrated_path_lengths = np.array(\n                [c.integrated_path_length for c in all_chains])\n            opt_step = np.array(list(range(len(all_chains))))\n            s = 7\n            fs = 18\n            ax = plt.figure(figsize=(1.16*s, s)).add_subplot(projection='3d')\n\n            # Plot a sin curve using the x and y axes.\n            x = opt_step\n            ys = all_integrated_path_lengths\n            zs = ens\n            for i, (xind, y) in enumerate(zip(x, ys)):\n                if i &lt; len(ys) - 1:\n                    ax.plot([xind]*len(y), y, 'o-', zs=zs[i],\n                            color='gray', markersize=3, alpha=.1)\n                else:\n                    ax.plot([xind]*len(y), y, 'o-', zs=zs[i],\n                            color='blue', markersize=3)\n            ax.grid(False)\n\n            ax.set_xlabel('optimization step', fontsize=fs)\n            ax.set_ylabel('integrated path length', fontsize=fs)\n            ax.set_zlabel('energy (hartrees)', fontsize=fs)\n\n            # Customize the view angle so it's easier to see that the scatter points lie\n            # on the plane y=0\n            ax.view_init(elev=20., azim=-45)\n            plt.tight_layout()\n            plt.show()\n\n        else:\n            f, ax = plt.subplots(figsize=(1.16 * s, s))\n\n            for i, chain in enumerate(self.chain_trajectory):\n                if i == len(self.chain_trajectory) - 1:\n                    plt.plot(chain.integrated_path_length,\n                             chain.energies, \"o-\", alpha=1)\n                else:\n                    plt.plot(\n                        chain.integrated_path_length,\n                        chain.energies,\n                        \"o-\",\n                        alpha=0.1,\n                        color=\"gray\",\n                    )\n\n            plt.xlabel(\"Integrated path length\", fontsize=fs)\n\n            plt.ylabel(\"Energy (kcal/mol)\", fontsize=fs)\n            plt.xticks(fontsize=fs)\n            plt.yticks(fontsize=fs)\n            plt.show()\n\n    def plot_convergence_metrics(self, do_indiv=False):\n        ct = self.chain_trajectory\n\n        avg_rms_gperp = []\n        max_rms_gperp = []\n        avg_rms_g = []\n        barr_height = []\n        ts_gperp = []\n\n        for ind in range(1, len(ct)):\n            avg_rms_g.append(\n                sum(ct[ind].rms_gradients[1:-1]) / (len(ct[ind])-2))\n            avg_rms_gperp.append(\n                sum(ct[ind].rms_gperps[1:-1]) / (len(ct[ind])-2))\n            max_rms_gperp.append(max(ct[ind].rms_gperps))\n            barr_height.append(\n                abs(ct[ind].get_eA_chain() - ct[ind-1].get_eA_chain()))\n            ts_node_ind = ct[ind].energies.argmax()\n            ts_node_gperp = np.max(ct[ind].get_g_perps()[ts_node_ind])\n            ts_gperp.append(ts_node_gperp)\n\n        if do_indiv:\n            def plot_with_hline(data, label, y_hline, hline_label, hline_color, ylabel):\n                f, ax = plt.subplots()\n                plt.plot(data, label=label)\n                plt.ylabel(ylabel)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(y=y_hline, xmin=xmin, xmax=xmax,\n                          label=hline_label, linestyle='--', color=hline_color)\n                f.legend()\n                plt.show()\n\n            # Plot RMS Grad$_{\\perp}$\n            plot_with_hline(avg_rms_gperp, label='RMS Grad$_{\\perp}$',\n                            y_hline=self.parameters.rms_grad_thre,\n                            hline_label='rms_grad_thre', hline_color='blue',\n                            ylabel=\"Gradient data\")\n\n            # Plot Max RMS Grad$_{\\perp}$\n            plot_with_hline(max_rms_gperp, label='Max RMS Grad$_{\\perp}$',\n                            y_hline=self.parameters.max_rms_grad_thre,\n                            hline_label='max_rms_grad_thre', hline_color='orange',\n                            ylabel=\"Gradient data\")\n\n            # Plot TS gperp\n            plot_with_hline(ts_gperp, label='TS gperp',\n                            y_hline=self.parameters.ts_grad_thre,\n                            hline_label='ts_grad_thre', hline_color='green',\n                            ylabel=\"Gradient data\")\n\n            # Plot barrier height\n            plot_with_hline(barr_height, label='barr_height_delta',\n                            y_hline=self.parameters.barrier_thre,\n                            hline_label='barrier_thre', hline_color='purple',\n                            ylabel=\"Barrier height data\")\n\n        else:\n            # Define the data and parameters\n            data_list = [\n                (avg_rms_gperp, 'RMS Grad$_{\\perp}$',\n                 self.parameters.rms_grad_thre, 'rms_grad_thre', 'blue'),\n                (max_rms_gperp, 'Max RMS Grad$_{\\perp}$',\n                 self.parameters.max_rms_grad_thre, 'max_rms_grad_thre', 'orange'),\n                (ts_gperp, 'TS gperp', self.parameters.ts_grad_thre,\n                 'ts_grad_thre', 'green')\n            ]\n\n            # Create subplots\n            f, ax = plt.subplots()\n\n            # Plot the gradient data\n            for data, label, hline, hline_label, color in data_list:\n                ax.plot(data, label=label)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(y=hline, xmin=xmin, xmax=xmax,\n                          label=hline_label, linestyle='--', color=color)\n\n            # Set y-axis label for gradient data\n            ax.set_ylabel(\"Gradient data\")\n\n            # Create a second y-axis for barrier height data\n            ax2 = ax.twinx()\n            ax2.plot(barr_height, 'o--',\n                     label='barr_height_delta', color='purple')\n            ax2.set_ylabel(\"Barrier height data\")\n            ax2.hlines(y=self.parameters.barrier_thre, xmin=xmin, xmax=xmax,\n                       label='barrier_thre', linestyle='--', color='purple')\n\n            # Show legends and plot\n            f.legend(loc='upper left')\n            plt.show()\n\n    def read_from_disk(fp: Path, history_folder: Path = None,\n                       chain_parameters=ChainInputs(),\n                       neb_parameters=NEBInputs(),\n                       gi_parameters=GIInputs(),\n                       optimizer=VelocityProjectedOptimizer()):\n        if isinstance(fp, str):\n            fp = Path(fp)\n\n        if history_folder is None:\n            history_folder = fp.parent / (str(fp.stem) + \"_history\")\n\n        if not history_folder.exists():\n            raise ValueError(\"No history exists for this. Cannot load object.\")\n        else:\n            history_files = list(history_folder.glob(\"*.xyz\"))\n            history = [\n                Chain.from_xyz(\n                    history_folder / f\"traj_{i}.xyz\", parameters=chain_parameters\n                )\n                for i, _ in enumerate(history_files)\n            ]\n\n        n = NEB(\n            initial_chain=history[0],\n            parameters=neb_parameters,\n            optimized=history[-1],\n            chain_trajectory=history,\n            optimizer=optimizer\n        )\n        return n\n</code></pre>"},{"location":"neb/#neb_dynamics.NEB.NEB.optimize_chain","title":"<code>optimize_chain()</code>","text":"<p>Main function. After an NEB object has been created, running this function will minimize the chain and return the elementary step results from the final minimized chain.</p> <p>Running this function will populate the <code>.chain_trajectory</code> object variable, which contains the history of the chains minimized. Once it is completed, you can use <code>.plot_opt_history()</code> to view the optimization over time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>initialized NEB object</p> required <p>Raises:     NoneConvergedException: If chain did not converge in alloted steps.</p> Source code in <code>neb_dynamics/NEB.py</code> <pre><code>def optimize_chain(self) -&gt; ElemStepResults:\n    \"\"\"\n    Main function. After an NEB object has been created, running this function will\n    minimize the chain and return the elementary step results from the final minimized chain.\n\n    Running this function will populate the `.chain_trajectory` object variable, which\n    contains the history of the chains minimized. Once it is completed, you can use\n    `.plot_opt_history()` to view the optimization over time.\n\n    Args:\n        self: initialized NEB object\n    Raises:\n        NoneConvergedException: If chain did not converge in alloted steps.\n    \"\"\"\n\n    nsteps = 1\n    nsteps_negative_grad_corr = 0\n\n    if self.parameters.preopt_with_xtb:\n        chain_previous = self._do_xtb_preopt(self.initial_chain)\n        self.chain_trajectory.append(chain_previous)\n\n        stop_early, elem_step_results = self._do_early_stop_check(\n            chain_previous)\n        self.geom_grad_calls_made += elem_step_results.number_grad_calls\n        if stop_early:\n            return elem_step_results\n    else:\n        chain_previous = self.initial_chain.copy()\n        self.chain_trajectory.append(chain_previous)\n    chain_previous._zero_velocity()\n\n    while nsteps &lt; self.parameters.max_steps + 1:\n        if nsteps &gt; 1:\n            stop_early, elem_step_results = self._check_early_stop(\n                chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n\n        new_chain = self.update_chain(chain=chain_previous)\n        max_rms_grad_val = np.amax(new_chain.rms_gperps)\n        ind_ts_guess = np.argmax(new_chain.energies)\n        ts_guess_grad = np.amax(\n            np.abs(new_chain.get_g_perps()[ind_ts_guess]))\n        converged = chain_converged(\n            chain_prev=chain_previous, chain_new=new_chain,\n            parameters=self.parameters)\n        if converged and self.parameters.v:\n            print(\"\\nConverged!\")\n\n        n_nodes_frozen = 0\n        for node in new_chain:\n            if node.converged:\n                n_nodes_frozen += 1\n\n        grad_calls_made = len(new_chain) - n_nodes_frozen\n        self.grad_calls_made += grad_calls_made\n\n        grad_corr = new_chain._gradient_correlation(chain_previous)\n        if grad_corr &lt; 0:\n            nsteps_negative_grad_corr += 1\n        else:\n            nsteps_negative_grad_corr = 0\n\n        if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n            print(\"\\nstep size causing oscillations. decreasing by 50%\")\n            self.optimizer.timestep *= 0.5\n            nsteps_negative_grad_corr = 0\n\n        if self.parameters.v:\n\n            print(\n                f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                    max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                        {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                              {n_nodes_frozen} // {grad_corr}{' '*20}\", end=\"\\r\"\n            )\n            sys.stdout.flush()\n\n        self.chain_trajectory.append(new_chain)\n        self.gradient_trajectory.append(new_chain.gradients)\n\n        if converged:\n            if self.parameters.v:\n                print(\"\\nChain converged!\")\n\n            elem_step_results = check_if_elem_step(new_chain)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            self.optimized = new_chain\n            return elem_step_results\n\n        chain_previous = new_chain\n        nsteps += 1\n\n    new_chain = self.update_chain(chain=chain_previous)\n    if not chain_converged(chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters):\n        raise NoneConvergedException(\n            trajectory=self.chain_trajectory,\n            msg=f\"\\nChain did not converge at step {nsteps}\",\n            obj=self,\n        )\n</code></pre>"},{"location":"neb/#neb_dynamics.NEB.NEB.set_climbing_nodes","title":"<code>set_climbing_nodes(chain)</code>","text":"<p>Iterates through chain and sets the nodes that should climb.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>chain to set inputs for</p> required Source code in <code>neb_dynamics/NEB.py</code> <pre><code>def set_climbing_nodes(self, chain: Chain) -&gt; None:\n    \"\"\"Iterates through chain and sets the nodes that should climb.\n\n    Args:\n        chain: chain to set inputs for\n    \"\"\"\n    if self.parameters.climb:\n        inds_maxima = [chain.energies.argmax()]\n\n        if self.parameters.v &gt; 0:\n            print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n        for ind in inds_maxima:\n            chain[ind].do_climb = True\n</code></pre>"},{"location":"tdstructure/","title":"Tdstructure","text":"<p>this is the object that will contains all the info for a single Three D structure</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>@dataclass\nclass TDStructure:\n    \"\"\"\n    this is the object that will contains all the info for a single Three D structure\n    \"\"\"\n\n    molecule_obmol: openbabel.OBMol\n\n    tc_model_method: str = \"b3lyp\"\n    tc_model_basis: str = \"6-31g\"\n\n    tc_kwds: dict = field(default_factory=dict)\n    tc_geom_opt_kwds: dict = field(\n        default_factory=lambda: {\"maxiter\": 300, \"trust\": 0.005}\n    )\n    # tc_c0: bytes = b\"\"\n\n    _cached_nma: list = None\n    _cached_freqs: list = None\n\n    @property\n    def tc_d_model(self):\n        return {\"method\": self.tc_model_method, \"basis\": self.tc_model_basis}\n\n    @property\n    def coords(self) -&gt; np.array:\n        \"\"\"\n        this return coordinates in Angstroms\n        \"\"\"\n        return np.array(\n            [\n                (atom.x(), atom.y(), atom.z())\n                for atom in openbabel.OBMolAtomIter(self.molecule_obmol)\n            ]\n        )\n\n    @classmethod\n    def from_molecule(cls, rp_mol: Molecule, charge=0, spinmult=1) -&gt; TDStructure:\n        \"\"\"Instantiate object from `Molecule` object. see [link](https://mtzgroup.github.io/neb-dynamics/molecule/)\n\n        Args:\n            rp_mol (Molecule): Molecule object to build TDStructure from\n            charge (int, optional): charge of molecule. Defaults to 0.\n            spinmult (int, optional): spin multiplicity of molecule. Defaults to 1.\n\n        \"\"\"\n\n        d = {\"single\": 1, \"double\": 2, \"triple\": 3, \"aromatic\": 1.5}\n\n        obmol = openbabel.OBMol()\n\n        for i, _ in enumerate(rp_mol.nodes):\n\n            node = rp_mol.nodes[i]\n\n            atom_symbol = node[\"element\"]\n\n            atom_number = symbol_to_atomic_number(atom_symbol)\n            atom = openbabel.OBAtom()\n            atom.SetVector(0, 0, 0)\n            atom.SetAtomicNum(atom_number)\n            atom.SetFormalCharge(node[\"charge\"])\n            atom.SetId(i + 1)\n            obmol.AddAtom(atom)\n\n        for rp_atom1_id, rp_atom2_id in rp_mol.edges:\n            atom1_id = rp_atom1_id\n            atom2_id = rp_atom2_id\n            if type(atom1_id) is np.int64:\n                atom1_id = int(atom1_id)\n            if type(atom2_id) is np.int64:\n                atom2_id = int(atom2_id)\n\n            atom1 = obmol.GetAtom(atom1_id + 1)\n            atom2 = obmol.GetAtom(atom2_id + 1)\n\n            bond = openbabel.OBBond()\n            bond.SetBegin(atom1)\n            bond.SetEnd(atom2)\n\n            bond_order = rp_mol.edges[(rp_atom1_id, rp_atom2_id)][\"bond_order\"]\n            if d[bond_order] == 1.5:  # i.e., if an aromatic bond\n                bond.SetAromatic(True)\n                bond.SetBondOrder(4)\n            else:\n                bond.SetBondOrder(d[bond_order])\n\n            obmol.AddBond(bond)\n\n        arg = pybel.Molecule(obmol)\n        arg.make3D()\n        arg.localopt(\"uff\", steps=2000)\n        arg.localopt(\"gaff\", steps=2000)\n        arg.localopt(\"mmff94\", steps=2000)\n\n        obmol3D = arg.OBMol\n        obmol3D.SetTotalCharge(charge)\n        obmol3D.SetTotalSpinMultiplicity(spinmult)\n\n        return cls(obmol3D)\n\n    @property\n    def n_fragments(self) -&gt; int:\n        \"\"\"computes the number of separate molecules in TDStructure\n\n        Returns:\n            int: number of molecules in TDStructure\n        \"\"\"\n\n        n_frags = self.molecule_rp.separate_graph_in_pieces()\n        return len(n_frags)\n\n    @property\n    def mass_weight_coords(self) -&gt; np.array:\n        labels = self.symbols\n        coords = self.coords\n        weights = np.array([np.sqrt(get_mass(s)) for s in labels])\n        weights = weights / sum(weights)\n        coords = coords * weights.reshape(-1, 1)\n        return coords\n\n    @property\n    def coords_bohr(self) -&gt; np.array:\n        return self.coords * ANGSTROM_TO_BOHR\n\n    def update_coords(self, coords: np.array) -&gt; TDStructure:\n        \"\"\"updates the coordinates of the TDStructure to be those of `coords`.\n\n        Args:\n            coords: coords to update TDStructure to\n\n        \"\"\"\n        np.testing.assert_array_equal(coords.shape, self.coords.shape,\n                                      err_msg=f\"Input array shape ({coords.shape}) does not match \\\n                                        existing shape ({self.coords.shape})\")\n\n        string = write_xyz(self.symbols, coords)\n\n        with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w\", delete=False) as tmp:\n            tmp.write(string)\n\n        td = TDStructure.from_xyz(\n            tmp.name, charge=self.charge, spinmult=self.spinmult\n        )\n        os.remove(tmp.name)\n        return td\n\n    @contextlib.contextmanager\n    def remember_cwd(self):\n        curdir = os.getcwd()\n        try:\n            yield\n        finally:\n            os.chdir(curdir)\n\n    @property\n    def symbols(self):\n        return np.array(\n            [\n                atomic_number_to_symbol(atom.atomicnum)\n                for atom in pybel.Molecule(self.molecule_obmol).atoms\n            ]\n        )\n\n    def align_to_td(self, other_td: TDStructure) -&gt; TDStructure:\n        \"\"\"Aligns geometry to `other_td` to minimize RMSD. Uses Kabsch algorithm.\n\n        Args:\n            other_td (TDStructure): structure to align to\n\n        Returns:\n            TDStructure: aligned structure\n        \"\"\"\n        __, new_coords = align_geom(other_td.coords, self.coords)\n        new_td = self.update_coords(new_coords)\n        return new_td\n\n    def _symbol_to_atomic_number(self, s):\n        d = ElementData().from_symbol(s)\n        return d.atomic_num\n\n    @property\n    def atomic_numbers(self):\n        return np.array([self._symbol_to_atomic_number(s) for s in self.symbols])\n\n    def gum_mm_optimization(self):\n        self.mm_optimization(\"gaff\")\n        self.mm_optimization(\"uff\")\n        self.mm_optimization(\"mmff94\")\n\n    @property\n    def atom_iter(self):\n        obmol = self.molecule_obmol\n        return [\n            (\n                obmol.GetAtom(i + 1).GetAtomicNum(),\n                obmol.GetAtom(i + 1).GetFormalCharge(),\n            )\n            for i in range(obmol.NumAtoms())\n        ]\n\n    @property\n    def atomn(self):\n        \"\"\"\n        returns number of atoms\n        \"\"\"\n        return self.molecule_obmol.NumAtoms()\n\n    def view_mol(self, string_mode=False, style=\"sphere\", center=True, custom_image=\"\"):\n        if center:\n\n            def center(nested_array_list):\n                a = np.array(nested_array_list)\n                return np.mean(a, axis=0)\n\n            coords = self.coords - center(self.coords)\n        else:\n            coords = self.coords\n\n        frame = write_xyz(self.symbols, coords)\n        viewer = py3Dmol.view(width=400, height=400)\n        viewer.addModel(frame, \"xyz\")\n\n        if style == \"stick\":\n            viewer.setStyle({\"stick\": {}})\n        else:\n            viewer.setStyle({\"sphere\": {\"scale\": \"0.5\"}})\n\n        rp = self.molecule_rp\n        s = f\"\"\"\n        &lt;p style=\"text-align: left; font-weight: bold;\"&gt;{rp.smiles}&lt;/p&gt;\n        &lt;div style=\"width: 70%; display: table;\"&gt; &lt;div style=\"display: table-row;\"&gt;\n        &lt;div style=\"width: 20%; display: table-cell;\"&gt;\n        {viewer._make_html()}\n        &lt;/div&gt;\n        &lt;div style=\"width: 20%; display: table-cell; border: 1px solid black;\"&gt;\n        {rp.draw(string_mode=True)}\n        &lt;/div&gt;\n        &lt;div style=\"width: 40%; display: table-cell;\"&gt;\n        {custom_image}\n        &lt;/div&gt;\n        &lt;/div&gt;\n\n        \"\"\"\n        if string_mode:\n            return s\n        else:\n            return HTML(s)\n\n    def _repr_html_(self):\n        return self.view_mol(string_mode=True)\n\n    @property\n    def formal_charges(self):\n        return [\n            atom.GetFormalCharge()\n            for atom in openbabel.OBMolAtomIter(self.molecule_obmol)\n        ]\n\n    @property\n    def atom_charge_iter(self):\n        \"\"\"\n        iter through atomic number and charge for every atom in OBmolecule\n        \"\"\"\n        return (\n            (atom.GetAtomicNum(), atom.GetFormalCharge())\n            for atom in openbabel.OBMolAtomIter(self.molecule_obmol)\n        )\n\n    @property\n    def edge_iter(self):\n        return (\n            (\n                bond.GetBeginAtomIdx() - 1,\n                bond.GetEndAtomIdx() - 1,\n                1.5 if bond.IsAromatic() else bond.GetBondOrder(),\n            )\n            for bond in openbabel.OBMolBondIter(self.molecule_obmol)\n        )\n\n    @property\n    def charge(self):\n        return self.molecule_obmol.GetTotalCharge()\n\n    @property\n    def spinmult(self):\n        return self.molecule_obmol.GetTotalSpinMultiplicity()\n        # return self.tot_spinmult\n\n    @property\n    def molecule_rp(self):\n        \"\"\"\n        converts an openbabel molecule to a retropaths molecule\n        \"\"\"\n        new_mol = Molecule()\n        for i, (y, z) in enumerate(self.atom_iter):\n            new_mol.add_node(\n                i, neighbors=0, element=from_number_to_element(y), charge=z\n            )\n        for i, j, k in self.edge_iter:\n            if k == 4:\n                k_prime = 1.5\n            else:\n                k_prime = k\n            new_mol.add_edge(\n                i, j, bond_order=bond_ord_number_to_string(k_prime))\n        new_mol.set_neighbors()\n        return new_mol\n\n    def to_ASE_atoms(self) -&gt; Atoms:\n        \"\"\"converts TDStructure into `Atoms` object for usage with ASE.\n\n        Returns:\n            Atoms: TDStructure converted to Atoms object from ASE\n        \"\"\"\n        # XTB api is summing the initial charges from the ATOM object.\n        # it returns a vector of charges (maybe Mulliken), but to initialize the calculation,\n        # it literally sums this vector up. So we create a zero vector (natoms long) and we\n        # modify the charge of the first atom to be total charge.\n        charges = np.zeros(self.atomn)\n        charges[0] = self.charge\n\n        spins = np.zeros(self.atomn)\n        spins[0] = self.spinmult - 1\n\n        atoms = Atoms(\n            symbols=self.symbols.tolist(),\n            positions=self.coords,\n            charges=charges,\n            magmoms=spins,\n        )\n        return atoms\n\n    def xtb_geom_optimization(self, return_traj=False) -&gt; Union[List[TDStructure], TDStructure]:\n        \"\"\"\n        Run geometry optimization using XTB Calculator in ASE.\n\n        Args:\n            return_traj: Whether to return a list of tdstructures of the optimziation trajectory\n        \"\"\"\n\n        tmp = tempfile.NamedTemporaryFile(\n            suffix=\".traj\", mode=\"w+\", delete=False)\n\n        atoms = self.to_ASE_atoms()\n        # print(tmp.name)\n\n        atoms.calc = XTB(method=\"GFN2-xTB\", accuracy=0.001)\n        # opt = LBFGSLineSearch(atoms, logfile=None, trajectory=tmp.name)\n        opt = SciPyFminCG(atoms, logfile=None, trajectory=tmp.name)\n        # opt = Sella(atoms, logfile=None, trajectory=tmp.name)\n        # opt = LBFGS(atoms, logfile=None, trajectory='/tmp/log.traj')\n        # opt = FIRE(atoms, logfile=None)\n        opt.run(fmax=0.01)\n        # opt.run(fmax=0.5)\n\n        aT = ASETraj(tmp.name)\n        traj_list = []\n        for i, _ in enumerate(aT):\n            traj_list.append(\n                TDStructure.from_ase_Atoms(\n                    aT[i], charge=self.charge, spinmult=self.spinmult\n                )\n            )\n        traj = [td.update_tc_parameters(self) for td in traj_list]\n\n        Path(tmp.name).unlink()\n        if return_traj:\n            print(\"len opt traj: \", len(traj))\n            return traj\n        else:\n            return traj[-1]\n\n    def xtb_sella_geom_optimization(self, return_traj=False):\n        \"\"\"\n        Use SELLA and XTB to minimize the geometry.\n\n        Args:\n            return_traj: Whether to return a list of tdstructures of the optimziation trajectory\n        \"\"\"\n        tmp = tempfile.NamedTemporaryFile(\n            suffix=\".traj\", mode=\"w+\", delete=False)\n\n        atoms = self.to_ASE_atoms()\n        # print(tmp.name)\n\n        atoms.calc = XTB(method=\"GFN2-xTB\", accuracy=0.001)\n        opt = Sella(atoms, logfile=None, trajectory=tmp.name)\n        opt.run(fmax=0.01)\n\n        aT = ASETraj(tmp.name)\n        traj_list = []\n        for i, _ in enumerate(aT):\n            traj_list.append(\n                TDStructure.from_ase_Atoms(\n                    aT[i], charge=self.charge, spinmult=self.spinmult\n                )\n            )\n        traj = [td.update_tc_parameters(self) for td in traj_list]\n\n        Path(tmp.name).unlink()\n        if return_traj:\n            print(\"len opt traj: \", len(traj))\n            return traj\n        else:\n            return traj[-1]\n\n    def copy(self):\n        obmol = self.molecule_obmol\n        copy_obmol = openbabel.OBMol()\n        for atom in openbabel.OBMolAtomIter(obmol):\n            copy_obmol.AddAtom(atom)\n\n        for bond in openbabel.OBMolBondIter(obmol):\n            copy_obmol.AddBond(bond)\n\n        copy_obmol.SetTotalCharge(obmol.GetTotalCharge())\n        copy_obmol.SetTotalSpinMultiplicity(obmol.GetTotalSpinMultiplicity())\n\n        tc_model_method = self.tc_model_method\n        tc_model_basis = self.tc_model_basis\n\n        tc_kwds = self.tc_kwds.copy()\n        tc_geom_opt_kwds = self.tc_geom_opt_kwds.copy()\n        # tc_c0 = self.tc_c0\n\n        tds = TDStructure(\n            molecule_obmol=copy_obmol,\n            tc_model_method=tc_model_method,\n            tc_model_basis=tc_model_basis,\n            tc_kwds=tc_kwds,\n            tc_geom_opt_kwds=tc_geom_opt_kwds,\n            # tc_c0=tc_c0,\n        )\n\n        tds._cached_freqs = self._cached_freqs\n        tds._cached_nma = self._cached_nma\n\n        return tds\n\n    def mm_optimization(self, method=\"gaff\", steps=2000):\n        \"\"\"\n        in place MM optimization\n        \"\"\"\n        pybel_mol = pybel.Molecule(self.molecule_obmol)\n        pybel_mol.localopt(method, steps=steps)\n        self.molecule_obmol = pybel_mol.OBMol\n\n    @property\n    def xyz(self):\n        return write_xyz(self.symbols, self.coords)\n\n    def to_xyz(self, fn: Path):\n        with open(fn, \"w+\") as f:\n            f.write(self.xyz)\n        f.close()\n\n    def to_pdb(self, fn: Path) -&gt; None:\n        \"\"\"Writes molecule to PDB format\n        \"\"\"\n        mol_pybel = pybel.Molecule(self.molecule_obmol)\n        mol_pybel.write(format=\"pdb\", filename=str(fn), overwrite=True)\n\n    def move_atom(self, atom_index, new_x, new_y, new_z):\n        \"\"\"\n        this method moves the atom to the new coordinates\n        \"\"\"\n        atom = self.molecule_obmol.GetAtom(atom_index + 1)\n        atom.SetVector(new_x, new_y, new_z)\n\n    def energy_xtb(self) -&gt; float:\n        \"\"\"returns XTB energy of TDStructure\n        \"\"\"\n        try:\n            calc = Calculator(\n                get_method(\"GFN2-xTB\"),\n                self.atomic_numbers,\n                self.coords_bohr,\n                charge=self.charge,\n                uhf=self.spinmult - 1,\n            )\n            calc.set_verbosity(VERBOSITY_MUTED)\n            res = calc.singlepoint()\n            return res.get_energy()\n        except XTBException:\n            return None\n\n    def gradient_xtb(self) -&gt; np.array:\n        \"\"\"\n        return XTB gradient of TDStructure\n        \"\"\"\n        calc = Calculator(\n            get_method(\"GFN2-xTB\"),\n            self.atomic_numbers,\n            self.coords_bohr,\n            charge=self.charge,\n            uhf=self.spinmult - 1,\n        )\n        calc.set_verbosity(VERBOSITY_MUTED)\n        res = calc.singlepoint()\n        return res.get_gradient() * BOHR_TO_ANGSTROMS\n\n    def set_charge(self, charge):\n        \"\"\"\n        sets charge of TDStructure\n        \"\"\"\n        self.molecule_obmol.SetTotalCharge(charge)\n\n    def set_spinmult(self, tot_spinmult):\n        \"\"\"\n        sets spin multiplicity of TDStructure\n        \"\"\"\n        self.molecule_obmol.SetTotalSpinMultiplicity(tot_spinmult)\n\n    @classmethod\n    def from_ase_Atoms(cls, atoms: Atoms, charge: int, spinmult: int) -&gt; TDStructure:\n        \"\"\"\n        instantiates TDStructure from ASE Atoms object.\n\n        Args:\n            atoms: ASE Atoms object\n            charge: system charge\n            spinmult: system spin multiplicity\n\n        \"\"\"\n        atomT = np.asarray([from_number_to_element(x) for x in atoms.numbers])\n        string = write_xyz(atomT, atoms.get_positions())\n\n        with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w\", delete=False) as tmp:\n            tmp.write(string)\n\n        td = cls.from_xyz(tmp.name, charge=charge, spinmult=spinmult)\n        os.remove(tmp.name)\n        return td\n\n    @classmethod\n    def from_mapped_smiles(cls, smi: str, spinmult: int = 1, charge: int = 0) -&gt; TDStructure:\n        \"\"\"\n        creates a TDStructure from a mapped smiles format\n\n        Args:\n            smi: mapped smiles to use\n            spinmult: system spinmultiplicity\n            charge: system charge\n        \"\"\"\n        mol = Molecule.from_mapped_smiles(smi)\n        obj = cls.from_molecule(mol, charge=charge, spinmult=spinmult)\n        return obj\n\n    @classmethod\n    def from_smiles(cls, smi: str, tot_spinmult: int = 1):\n        \"\"\"\n        creates a TDStructure from a smiles format\n\n        Args:\n            smi: smiles to use\n            spinmult: system spinmultiplicity\n        \"\"\"\n        pybel_mol = pybel.readstring(\"smi\", smi)\n        pybel_mol.make3D()\n        pybel_mol.localopt(\"gaff\")\n        obmol = pybel_mol.OBMol\n        obmol.SetTotalSpinMultiplicity(tot_spinmult)\n        obj = cls(molecule_obmol=obmol)\n        obj.gum_mm_optimization()\n        return obj\n\n    @classmethod\n    def from_xyz(cls, fp: Path, charge=0, spinmult=1) -&gt; TDStructure:\n        \"\"\"\n        creates a TDStructure from an xyz file\n\n        Args:\n            fp: path to xyz file to open\n            spinmult: system spinmultiplicity\n            charge: system charge\n        \"\"\"\n        if isinstance(fp, str):\n            fp = Path(fp)\n        # if \"OE_LICENSE\" not in os.environ:\n        obmol = load_obmol_from_fp(fp)\n        obmol.SetTotalCharge(charge)\n        obmol.SetTotalSpinMultiplicity(spinmult)\n        return cls(molecule_obmol=obmol)\n\n        # else:\n        #     ifs = oechem.oemolistream()\n        #     ifs.SetFormat(oechem.OEFormat_XYZ)\n        #     if ifs.open(str(fp.resolve())):\n        #         for mol in ifs.GetOEGraphMols():\n        #             return cls.from_oe(\n        #                 mol, tot_charge=tot_charge, tot_spinmult=tot_spinmult\n        #             )\n\n    @classmethod\n    def from_cc_result(cls, result: ResultsType) -&gt; TDStructure:\n        \"\"\"\n        Build TDStructure from ChemCloud results object\n\n        Args:\n            result: qcio results object see [link](https://mtzgroup.github.io/chemcloud-client/)\n        \"\"\"\n        if hasattr(result, \"final_molecule\"):\n            mol = result.final_molecule\n        else:\n            mol = result.molecule\n\n        coords = mol.geometry\n        symbols = mol.symbols\n\n        td = TDStructure.from_coords_symbols(\n            coords=coords * (BOHR_TO_ANGSTROMS),\n            symbols=symbols,\n            tot_charge=int(mol.charge),\n            tot_spinmult=mol.multiplicity,\n        )\n\n        return td\n\n    @classmethod\n    def from_xyz_string(cls, string, tot_charge=0, tot_spinmult=1):\n        with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w\", delete=False) as tmp:\n            tmp.write(string)\n\n        td = cls.from_xyz(tmp.name, charge=tot_charge,\n                          spinmult=tot_spinmult)\n        os.remove(tmp.name)\n        return td\n\n    @classmethod\n    def from_coords_symbols(cls, coords, symbols, tot_charge=0, tot_spinmult=1):\n        if not isinstance(coords, type(np.array)):\n            coords = np.array(coords)\n        string = write_xyz(symbols, coords)\n        return cls.from_xyz_string(\n            string, tot_charge=tot_charge, tot_spinmult=tot_spinmult\n        )\n\n    def update_tc_parameters(self, td_ref: TDStructure) -&gt; None:\n        \"\"\"\n        updates the TC parameters INPLACE for `self` from a reference TDStructure.\n\n        !!! Warning\n            This update is done INPLACE.\n\n        Args:\n            td_ref: reference TDStructure\n        \"\"\"\n        tc_model_method = td_ref.tc_model_method\n        tc_model_basis = td_ref.tc_model_basis\n        tc_kwds = td_ref.tc_kwds.copy()\n        tc_geom_opt_kwds = td_ref.tc_geom_opt_kwds.copy()\n\n        self.tc_model_method = tc_model_method\n        self.tc_model_basis = tc_model_basis\n        self.tc_kwds = tc_kwds\n        self.tc_geom_opt_kwds = tc_geom_opt_kwds\n\n    def update_tc_parameters_from_inpfile(self, file_path: str, read_in_charges_spinmult: bool = False) -&gt; TDStructure:\n        \"\"\"updates TC parameters from a terachem input file. Returns a COPY\n\n        !!! Warning\n            This update is NOT done in place. An updated copy is returned.\n\n        Args:\n            file_path: file path to Terachem input file\n            read_in_charges_spinmult: Whether to replace TDStructure `charge` \\\n                and `spinmult` values with whatever is specified in the input file.\n        \"\"\"\n        td_copy = self.copy()\n\n        method, basis, charge, spinmult, inp_kwds = _load_info_from_tcin(\n            file_path)\n        if charge and read_in_charges_spinmult:\n            print(\n                f\"Warning!: Setting charge to what is specified in {file_path}\")\n            td_copy.set_charge(charge)\n\n        if spinmult and read_in_charges_spinmult:\n            print(\n                f\"Warning!: Setting multiplicity to what is specified in {file_path}\")\n            td_copy.set_spinmult(spinmult)\n\n        td_copy.tc_model_method = method\n        td_copy.tc_model_basis = basis\n        td_copy.tc_kwds = inp_kwds\n\n        return td_copy\n\n    @property\n    def tc_client(self):\n        \"\"\"\n        stores chemcloud client\n        \"\"\"\n        client = CCClient()\n        return client\n\n    def _prepare_input(self, method):\n        \"\"\"\n        creates a qcio ProgramInput from TDStructure.\n        \"\"\"\n        allowed_methods = [\n            \"energy\",\n            \"optimization\",\n            \"gradient\",\n            \"transition_state\",\n            \"hessian\",\n        ]\n\n        if method.lower() not in allowed_methods:\n            print(f\"{method} not allowed. Methods: {allowed_methods}\")\n            return\n\n        # if self.tc_c0:\n        #     self.tc_kwds[\"guess\"] = \"c0\"\n\n        tc_mol = self.as_qcio_molecule()\n        if method in [\"energy\", \"gradient\"]:\n            # if self.tc_c0:\n            #     prog_input = ProgramInput(\n            #         calctype=method,\n            #         molecule=tc_mol,\n            #         model=self.tc_d_model,\n            #         keywords=self.tc_kwds,\n            #         files={\"c0\": self.tc_c0},\n            #     )\n            #     inp = prog_input\n            # else:\n            prog_input = ProgramInput(\n                calctype=method,\n                molecule=tc_mol,\n                model=self.tc_d_model,\n                keywords=self.tc_kwds,\n            )\n            inp = prog_input\n\n        elif method in [\"optimization\", \"transition_state\", \"hessian\"]:\n            # if self.tc_c0:\n            #     opt_input = DualProgramInput(\n            #         calctype=method,\n            #         molecule=tc_mol,\n            #         keywords=self.tc_geom_opt_kwds,\n            #         subprogram=ES_PROGRAM,\n            #         subprogram_args={\n            #             \"model\": self.tc_d_model,\n            #             \"keywords\": self.tc_kwds,\n            #         },\n            #         files={\"c0\": self.tc_c0},\n            #     )\n\n            # else:\n            if method != \"hessian\":\n                inp_kwds = self.tc_kwds\n            else:\n                inp_kwds = {}\n\n            opt_input = DualProgramInput(\n                calctype=method,\n                molecule=tc_mol,\n                keywords=inp_kwds,\n                subprogram=ES_PROGRAM,\n                subprogram_args={\n                    \"model\": self.tc_d_model,\n                    \"keywords\": self.tc_kwds,\n                },\n            )\n            inp = opt_input\n\n        return inp\n\n    def as_qcio_molecule(self):\n        \"\"\"\n        creates a qcio Molecule object from self\n        \"\"\"\n        d = {\n            \"symbols\": self.symbols,\n            \"geometry\": self.coords_bohr,\n            \"multiplicity\": self.spinmult,\n            \"charge\": self.charge,\n        }\n        tc_mol = TCMolecule(**d)\n        return tc_mol\n\n    def _tcpb_input_string(self):\n        tc_inp_str = f\"\"\"method {self.tc_model_method}\n        basis {self.tc_model_basis}\n        spinmult {self.spinmult}\n        charge {self.charge}\n        \"\"\"\n\n        # if bool(self.tc_c0):\n        #     with tempfile.NamedTemporaryFile(\n        #         suffix=\".xyz\", mode=\"wb\", delete=False\n        #     ) as tmp:\n        #         tmp.write(self.tc_c0)\n\n        #     tc_inp_str += f\"\\nguess {str(tmp.name)}\"\n\n        kwds_strings = \"\\n\".join(\n            f\"{pair[0]}  {pair[1]}\\n\" for pair in self.tc_kwds.items()\n        )\n        tc_inp_str += kwds_strings\n\n        return tc_inp_str\n\n    def compute_tc(self, program: str, calctype: str):\n        \"\"\"\n        uses ChemCloud to compute a property defined by `calctype`.\n        See [link](https://mtzgroup.github.io/chemcloud-client/tutorial/compute/)\n        \"\"\"\n        prog_input = self._prepare_input(method=calctype)\n\n        future_result = self.tc_client.compute(\n            program, prog_input, queue=q, collect_files=True, propagate_wfn=True\n        )\n        output = future_result.get()\n\n        if output.success:\n            # if \"scr.geometry/c0\" in output.files.keys():\n            #     self.tc_c0 = output.files[\"scr.geometry/c0\"]\n            return output.return_result\n\n        else:\n            output.ptraceback\n            print(f\"TeraChem {calctype} failed.\")\n            return None\n\n    def compute_tc_local(\n        self, program: str, calctype: str, return_object: bool = False\n    ):\n        \"\"\"\n        Uses qcop to compute properties. See [link](https://github.com/coltonbh/qcop)\n        \"\"\"\n        prog_input = self._prepare_input(method=calctype)\n\n        output = qcop.compute(\n            program, prog_input, propagate_wfn=True, collect_files=True\n        )\n\n        if output.success:\n            # if \"scr.geometry/c0\" in output.files.keys():\n            #     self.tc_c0 = output.files[\"scr.geometry/c0\"]\n            if return_object:\n                return output\n            return output.return_result\n\n        else:\n            output.ptraceback\n            print(f\"TeraChem {calctype} failed.\")\n            if return_object:\n                return output\n            return None\n\n    def tc_freq_calculation(self):\n        \"\"\"\n        returns frequences from hessian calculation using bigchem\n        \"\"\"\n        freqs, _ = self.tc_freq_nma_calculation()\n        return freqs\n\n    def tc_nma_calculation(self):\n        \"\"\"\n        returns normal modes from hessian calculation using bigchem\n        \"\"\"\n        _, nmas = self.tc_freq_nma_calculation()\n\n        nmas_flat = nmas\n        nmas_reshaped = []\n        for nma in nmas_flat:\n            nma_arr = np.array(nma)\n            nmas_reshaped.append(nma_arr.reshape(self.coords.shape))\n\n        return nmas_reshaped\n\n    def tc_freq_nma_calculation(self):\n        if self._cached_nma is None or self._cached_freqs is None:\n            prog_input = self._prepare_input(method=\"hessian\")\n            future_result = self.tc_client.compute(\n                \"bigchem\", prog_input, queue=q)\n            output = future_result.get()\n\n            if output.success:\n                freqs, nmas = (\n                    output.results.freqs_wavenumber,\n                    output.results.normal_modes_cartesian,\n                )\n\n                self._cached_nma = nmas\n                self._cached_freqs = freqs\n                return freqs, nmas\n            else:\n                output.ptraceback\n                return None, None\n        else:\n            return self._cached_freqs, self._cached_nma\n\n    def energy_tc(self):\n        \"\"\"\n        energy for system using chemcloud\n        \"\"\"\n        return self.compute_tc(ES_PROGRAM, \"energy\")\n\n    def energy_tc_local(self):\n        \"\"\"\n        energy for system using local terachem\n        \"\"\"\n        return self.compute_tc_local(ES_PROGRAM, \"energy\")\n\n    def gradient_tc(self):\n        \"\"\"\n        gradient for system using chemcloud\n        \"\"\"\n        return self.compute_tc(ES_PROGRAM, \"gradient\")\n\n    def gradient_tc_local(self):\n        \"\"\"\n        gradient for system using local terachem\n        \"\"\"\n        return self.compute_tc_local(ES_PROGRAM, \"gradient\")\n\n    def tc_geom_optimization(self, method=\"minima\"):\n        \"\"\"\n        geometry optimization for system using chemcloud\n\n        Args:\n            method: whether to do a \"minima\" or \"ts\" optimization. \\\n            uses `geometric` to carry out optimizations.\n        \"\"\"\n        if method == \"minima\":\n            opt_input = self._prepare_input(method=\"optimization\")\n        elif method == \"ts\":\n            opt_input = self._prepare_input(method=\"transition_state\")\n        else:\n            raise ValueError(\n                f\"Unrecognized method: {method}. Use either: 'minima', or 'ts'\"\n            )\n        pwfn_bool = ES_PROGRAM == \"terachem\"\n        future_result = self.tc_client.compute(\n            \"geometric\",\n            opt_input,\n            queue=q,\n            # this cannot be true is using psi4 for some reason...\n            propagate_wfn=pwfn_bool,\n        )\n        output = future_result.get()\n        result = output.results\n\n        if output.success:\n            print(\"Optimization succeeded!\")\n        else:\n            print(\"Optimization failed!\")\n            output.ptraceback\n\n        coords = result.final_molecule.geometry\n        symbols = result.final_molecule.symbols\n        td_opt_tc = TDStructure.from_coords_symbols(\n            coords=coords * (1 / ANGSTROM_TO_BOHR),\n            symbols=symbols,\n            tot_charge=int(result.final_molecule.charge),\n            tot_spinmult=result.final_molecule.multiplicity,\n        )\n\n        td_opt_tc.update_tc_parameters(self)\n\n        return td_opt_tc\n\n    def tc_local_geom_optimization(self, method=\"minima\"):\n        \"\"\"\n        geometry optimization for system using local terachem\n\n        Args:\n            method: whether to do a \"minima\" or \"ts\" optimization. \\\n            uses `geometric` in `qcop` to carry out optimizations.\n        \"\"\"\n        if method == \"minima\":\n            # opt_input = self._prepare_input(method=\"optimization\")\n            return self.run_tc_local(calculation=\"minimize\")\n        elif method == \"ts\":\n            opt_input = self._prepare_input(method=\"transition_state\")\n        else:\n            raise ValueError(\n                f\"Unrecognized method: {method}. Use either: 'minima', or 'ts'\"\n            )\n\n        output = qcop.compute(\n            \"geometric\",\n            opt_input,\n            queue=q,\n            # this cannot be true is using psi4 for some reason...\n            propagate_wfn=True,\n        )\n\n        result = output.results\n\n        if output.success:\n            print(\"Optimization succeeded!\")\n        else:\n            print(\"Optimization failed!\")\n            output.ptraceback\n\n        coords = result.final_molecule.geometry\n        symbols = result.final_molecule.symbols\n        td_opt_tc = TDStructure.from_coords_symbols(\n            coords=coords * (1 / ANGSTROM_TO_BOHR),\n            symbols=symbols,\n            tot_charge=int(result.final_molecule.charge),\n            tot_spinmult=result.final_molecule.multiplicity,\n        )\n\n        td_opt_tc.update_tc_parameters(self)\n\n        return td_opt_tc\n\n    def tc_local_ts_optimization(self, **kwargs):\n        \"\"\"\n        geometry optimization for system using local terachem.\n        Will attempt a transition state search.\n        \"\"\"\n        return self.run_tc_local(\n            calculation=\"ts\",\n            method=self.tc_model_method,\n            basis=self.tc_model_basis,\n            **kwargs,\n        )\n\n    def run_tc_local(self, calculation=\"energy\", remove_all=True, return_object=False):\n        \"\"\"\n        run a local terachem calculation\n\n        Args:\n            calculation: type of calculation to run. Supports 'energy', 'gradient', and 'minimize'\n        \"\"\"\n        # make the geometry file\n        with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w+\", delete=False) as tmp:\n            self.to_xyz(tmp.name)\n\n        # make the tc input file\n        inp = f\"\"\"run {calculation}\\ncoordinates {tmp.name}\\n\"\"\"\n        inp += self._tcpb_input_string()\n        inp += f\"\"\"scrdir {tmp.name[:-4]}\\nmaxiter 500\\n\"\"\"\n\n        if \"wf_guess\" in self.tc_kwds:\n            guess_path = self.tc_kwds[\"wf_guess\"]  # this must be a string\n            assert isinstance(\n                guess_path, str\n            ), f\"wavefunction guess in tc_kwds needs to be a string, not a {type(guess_path)}\"\n            inp += f\"\\nguess {guess_path}\"\n\n        with tempfile.NamedTemporaryFile(\n            suffix=\".in\", mode=\"w+\", delete=False\n        ) as tmp_inp:\n            tmp_inp.write(inp)\n\n        # run the tc calc\n        with tempfile.NamedTemporaryFile(\n            suffix=\".out\", mode=\"w+\", delete=False\n        ) as tmp_out:\n            out = subprocess.run(\n                [f\"terachem {tmp_inp.name}\"], shell=True, capture_output=True\n            )\n            tmp_out.write(out.stdout.decode())\n\n        if calculation == \"minimize\":\n            result = run_tc_local_optimization(\n                td=self, tmp=tmp, return_optim_traj=return_object\n            )\n\n        else:\n            result_obj = parse(tmp_out.name, program=\"terachem\")\n            if calculation == \"energy\":\n                result = result_obj.energy\n            elif calculation == \"gradient\":\n                result = result_obj.gradient\n            if return_object:\n                result = result_obj\n            else:\n                result = result_obj.return_result\n\n        # remove everything\n        if remove_all:\n            Path(tmp.name).unlink()\n            Path(tmp_inp.name).unlink()\n            Path(tmp_out.name).unlink()\n\n            shutil.rmtree(tmp.name[:-4])  # delete scratch dir\n        elif not remove_all:\n            print(f\"{tmp.name=} {tmp_inp.name=} {tmp_out.name=}\")\n        return result\n\n    def make_geom_and_inp_file(self, calculation=\"gradient\"):\n        \"\"\"\n        writes the geometry to disk and an input file.\n        Returns the file paths to each\n        \"\"\"\n\n        # make the geometry file\n        with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w+\", delete=False) as tmp:\n            self.to_xyz(tmp.name)\n\n        # make the tc input file\n        inp = f\"\"\"run {calculation}\n        coordinates {tmp.name}\n        method {self.tc_model_method}\n        basis {self.tc_model_basis}\n        charge {self.charge}\n        spinmult {self.spinmult}\n        scrdir {tmp.name[:-4]}\n        gpus  1\n        \"\"\"\n        with tempfile.NamedTemporaryFile(\n            suffix=\".in\", mode=\"w+\", delete=False\n        ) as tmp_inp:\n            tmp_inp.write(inp)\n\n        return tmp.name, tmp_inp.name\n\n    def displace_by_dr(self, dr):\n        ts_displaced = self.copy()\n        ts_displaced_by_dr = ts_displaced.update_coords(\n            ts_displaced.coords + dr)\n        return ts_displaced_by_dr\n\n    def split_td_into_frags(self):\n        root_mol = self.molecule_rp\n        mols = root_mol.separate_graph_in_pieces()\n\n        td_list = []\n        for mol in mols:\n            td = TDStructure.from_coords_symbols(\n                coords=self.coords[mol.nodes],\n                symbols=self.symbols[mol.nodes],\n                tot_charge=mol.charge,\n            )\n            td.update_tc_parameters(td_ref=self)\n            td_list.append(td)\n\n        return td_list\n\n    def _get_points_in_cavity(self, step=.5):\n        \"\"\"\n        returns a set of points that are inside the solvent cavity formed by\n        the structure. points are generated from a 3D grid with step size 'step'\n        \"\"\"\n        xmin, xmax, ymin, ymax, zmin, zmax = self.get_xyz_lims()\n\n        x_ = np.arange(xmin, xmax, step)\n        y_ = np.arange(ymin, ymax, step)\n        z_ = np.arange(zmin, zmax, step)\n\n        x, y, z = np.meshgrid(x_, y_, z_, indexing='ij')\n\n        @np.vectorize\n        def is_in_cavity(x, y, z):\n            for atom in openbabel.OBMolAtomIter(self.molecule_obmol):\n                vdw = openbabel.GetVdwRad(atom.GetAtomicNum())\n                atom_coords = np.array([atom.GetX(), atom.GetY(), atom.GetZ()])\n                dist_to_atom = np.linalg.norm(\n                    np.array([x, y, z]) - atom_coords)\n                if dist_to_atom &lt;= vdw:\n                    return x, y, z\n            return None\n\n        out = is_in_cavity(x, y, z).flatten()\n\n        # does not work if logic is changed to 'is not None'\n        p_in_cav = out[out != None]\n\n        arr = []\n        for p in p_in_cav:\n            arr.append(p)\n\n        p_in_cav = np.array(arr)\n        return p_in_cav\n\n    def _get_vdwr_lim(td, col_ind, sign=1):\n        \"\"\"\n        td: TDStructure\n        atom_ind: the index of the atom at the corner\n        col_ind: either 0, 1, or 2 correspoding to X, Y, Z. Assuming td.coords is shaped (Natom, 3)\n        sign: either +1 or -1 corresponding to whether the Vanderwals radius should be added or subtracted.\n                E.g. if atom is the xmin, sign should be -1.\n        \"\"\"\n        if sign == -1:\n            atom_ind = int(td.coords[:, col_ind].argmin())\n        elif sign == 1:\n            atom_ind = int(td.coords[:, col_ind].argmax())\n\n        atom = td.molecule_obmol.GetAtomById(atom_ind)\n        vdw_r = openbabel.GetVdwRad(atom.GetAtomicNum())\n        xlim = td.coords[:, col_ind][atom_ind] + (sign*vdw_r)\n        return xlim\n\n    def get_xyz_lims(self):\n        xmin = self._get_vdwr_lim(col_ind=0, sign=-1)\n        xmax = self._get_vdwr_lim(col_ind=0, sign=1)\n\n        ymax = self._get_vdwr_lim(col_ind=1, sign=1)\n        ymin = self._get_vdwr_lim(col_ind=1, sign=-1)\n\n        zmin = self._get_vdwr_lim(col_ind=2, sign=-1)\n        zmax = self._get_vdwr_lim(col_ind=2, sign=1)\n\n        return xmin, xmax, ymin, ymax, zmin, zmax\n\n    def _get_points_in_both_cavities(self, other_td, step=1):\n\n        xmin1, xmax1, ymin1, ymax1, zmin1, zmax1 = self.get_xyz_lims()\n        xmin2, xmax2, ymin2, ymax2, zmin2, zmax2 = other_td.get_xyz_lims()\n\n        xmin = min([xmin1, xmin2])\n        ymin = min([ymin1, ymin2])\n        zmin = min([zmin1, zmin2])\n\n        xmax = max([xmax1, xmax2])\n        ymax = max([ymax1, ymax2])\n        zmax = max([zmax1, zmax2])\n\n        # print(f\"{xmin=}, {xmax=},{ymin=}, {ymax=}, {zmin=}, {zmax=}\")\n        x_ = np.arange(xmin, xmax, step)\n        y_ = np.arange(ymin, ymax, step)\n        z_ = np.arange(zmin, zmax, step)\n\n        x, y, z = np.meshgrid(x_, y_, z_, indexing='ij')\n\n        @np.vectorize\n        def is_in_cavity(x, y, z):\n            flag1 = False\n            for atom in openbabel.OBMolAtomIter(self.molecule_obmol):\n                vdw = openbabel.GetVdwRad(atom.GetAtomicNum())\n                atom_coords = np.array([atom.GetX(), atom.GetY(), atom.GetZ()])\n                dist_to_atom = np.linalg.norm(\n                    np.array([x, y, z]) - atom_coords)\n                if dist_to_atom &lt;= vdw:\n                    flag1 = True\n\n            for atom in openbabel.OBMolAtomIter(other_td.molecule_obmol):\n                vdw = openbabel.GetVdwRad(atom.GetAtomicNum())\n                atom_coords = np.array([atom.GetX(), atom.GetY(), atom.GetZ()])\n                dist_to_atom = np.linalg.norm(\n                    np.array([x, y, z]) - atom_coords)\n                if dist_to_atom &lt;= vdw:\n                    if flag1:\n                        return x, y, z\n\n            return None\n\n        out = is_in_cavity(x, y, z).flatten()\n        # does not work if written as 'is not None'\n        p_in_cav = out[out != None]\n\n        arr = []\n        for p in p_in_cav:\n            arr.append(p)\n\n        p_in_cav = np.array(arr)\n        return p_in_cav\n\n    def compute_volume(self, step=1):\n        p_in_cav = self._get_points_in_cavity(step=step)\n        hull = ConvexHull(p_in_cav)\n        return hull.volume\n\n    def get_optimal_volume_step(self, initial_step=1, threshold=1, shrink_factor=0.5):\n        step = initial_step\n        prev_volume = self.compute_volume(step=step)\n        step_found = False\n        while not step_found:\n            step *= shrink_factor\n            vol = self.compute_volume(step=step)\n\n            delta = abs(vol - prev_volume)\n            print(f\"{step=} {vol=} {delta=}\")\n\n            if delta &lt;= threshold:\n                step_found = True\n\n            prev_volume = vol\n\n        return step\n\n    def plot_overlap_hulls(self, other_td, step=None, just_overlap=True,\n                           initial_step=1, threshold=1, shrink_factor=0.8):\n        if step is None:\n            step1 = self.get_optimal_volume_step(\n                initial_step=initial_step,\n                threshold=threshold,\n                shrink_factor=shrink_factor)\n\n            step2 = other_td.get_optimal_volume_step(\n                initial_step=initial_step,\n                threshold=threshold,\n                shrink_factor=shrink_factor)\n\n            step = min([step1, step2])\n\n        xmin1, xmax1, ymin1, ymax1, zmin1, zmax1 = self.get_xyz_lims()\n        xmin2, xmax2, ymin2, ymax2, zmin2, zmax2 = other_td.get_xyz_lims()\n\n        xmin = min([xmin1, xmin2])\n        ymin = min([ymin1, ymin2])\n        zmin = min([zmin1, zmin2])\n\n        xmax = max([xmax1, xmax2])\n        ymax = max([ymax1, ymax2])\n        zmax = max([zmax1, zmax2])\n\n        if just_overlap:\n            p_in_cav = self._get_points_in_both_cavities(other_td=other_td,\n                                                         step=step)\n\n            hull = ConvexHull(p_in_cav)\n\n        else:\n            p_in_cav1 = self._get_points_in_cavity(step=step)\n            p_in_cav2 = other_td._get_points_in_cavity(step=step)\n\n            hull1 = ConvexHull(p_in_cav1)\n            hull2 = ConvexHull(p_in_cav2)\n\n        s = 5\n        fig = plt.figure(figsize=(1.6*s, s))\n        ax = fig.add_subplot(111, projection='3d')\n\n        if just_overlap:\n\n            for simplex in hull.simplices:\n                plt.plot(p_in_cav[simplex, 0], p_in_cav[simplex,\n                         1], p_in_cav[simplex, 2], 'k--')\n        else:\n            for simplex in hull1.simplices:\n                plt.plot(p_in_cav1[simplex, 0], p_in_cav1[simplex, 1],\n                         p_in_cav1[simplex, 2], 'k--', color='blue')\n\n            for simplex in hull2.simplices:\n                plt.plot(p_in_cav2[simplex, 0], p_in_cav2[simplex, 1],\n                         p_in_cav2[simplex, 2], 'k--', color='red')\n\n        ax.set_xlabel('X Label')\n        ax.set_ylabel('Y Label')\n        ax.set_zlabel('Z Label')\n        ax.set_xlim(xmin, xmax)\n        ax.set_ylim(ymin, ymax)\n        ax.set_zlim(zmin, zmax)\n        if just_overlap:\n            plt.title(f'Volume: {hull.volume}')\n        else:\n            plt.title(f'Volumes: {hull1.volume}, {hull2.volume}')\n\n        plt.show()\n\n    def compute_overlap_volume(self, other_td, step):\n        p_in_cav = self._get_points_in_both_cavities(\n            other_td=other_td, step=step)\n        hull = ConvexHull(p_in_cav)\n        return hull.volume\n\n    def plot_convex_hull(self, step=None, plot_grid=False, plot_hull=True,\n                         initial_step=1, threshold=1, shrink_factor=0.8):\n        if step is None:\n            step = self.get_optimal_volume_step(\n                initial_step=initial_step, threshold=threshold, shrink_factor=shrink_factor)\n\n        xmin, xmax, ymin, ymax, zmin, zmax = self.get_xyz_lims()\n        p_in_cav = self._get_points_in_cavity(step=step)\n        hull = ConvexHull(p_in_cav)\n\n        s = 5\n        fig = plt.figure(figsize=(1.6*s, s))\n        ax = fig.add_subplot(projection='3d')\n\n        x_ = np.arange(xmin, xmax, step)\n        y_ = np.arange(ymin, ymax, step)\n        z_ = np.arange(zmin, zmax, step)\n\n        x, y, z = np.meshgrid(x_, y_, z_, indexing='ij')\n\n        if plot_grid:\n            for x, y, z in p_in_cav:\n                ax.scatter3D(xs=x, ys=y, zs=z, color='gray', alpha=.3)\n        # ax.scatter3D(xs=x,ys=y, zs=z, color='gray', alpha=.3)\n        if plot_hull:\n            for simplex in hull.simplices:\n                plt.plot(p_in_cav[simplex, 0], p_in_cav[simplex,\n                         1], p_in_cav[simplex, 2], 'k--')\n\n        ax.set_xlabel('X Label')\n        ax.set_ylabel('Y Label')\n        ax.set_zlabel('Z Label')\n        ax.set_xlim(xmin, xmax)\n        ax.set_ylim(ymin, ymax)\n        ax.set_zlim(zmin, zmax)\n        plt.title(f'Volume: {round(hull.volume,3)}')\n\n        return fig\n\n    def compute_SASA(td: TDStructure):\n        with tempfile.NamedTemporaryFile(suffix=\".pdb\", mode=\"w\", delete=False) as tmp:\n            td.to_pdb(tmp.name)\n            p = PDBParser(QUIET=0)\n\n            struct = p.get_structure(tmp.name, tmp.name)\n            sr = ShrakeRupley()\n            sr.compute(struct, level=\"S\")\n\n        os.remove(tmp.name)\n\n        return round(struct.sasa)\n\n    def sample_all_conformers(self, dd: Path, fn: str = None, verbose=True,\n                              CREST_ewin=6.0, CREST_temp=298.15):\n\n        if fn is None:\n            fn = 'tdstructure.xyz'\n\n        confs_fp = dd / fn\n        self.to_xyz(confs_fp)\n        with self.remember_cwd():\n            os.chdir(dd)\n\n            fps_confomers = list(dd.glob(\"crest_conf*.xyz\"))\n            fps_rotamers = list(dd.glob(\"crest_rot*.xyz\"))\n            conformers_already_sampled = len(\n                fps_confomers) &gt;= 1 and len(fps_rotamers) &gt;= 1\n\n            if conformers_already_sampled:\n                if verbose:\n                    print(\"\\tConformers already computed.\")\n            else:\n                if verbose:\n                    print(\"\\tRunning conformer sampling...\")\n\n                output = subprocess.run(\n                    [\n                        \"crest\",\n                        f\"{str(confs_fp.resolve())}\",\n                        f\"-ewin {CREST_ewin}\",\n                        f\"-temp {CREST_temp}\",\n                        \"--gfn2\",\n                    ],\n                    capture_output=True,\n                )\n                if verbose:\n                    print(\n                        f\"\\tWriting CREST output stream to {str((dd / 'crest_output.txt').resolve())}...\"\n                    )\n                with open(dd / \"crest_output.txt\", \"w+\") as fout:\n                    fout.write(output.stdout.decode(\"utf-8\"))\n                fout.close()\n                if verbose:\n                    print(\"\\tDone!\")\n\n                fps_confomers = list(dd.glob(\"crest_conf*.xyz\"))\n                fps_rotamers = list(dd.glob(\"crest_rot*.xyz\"))\n\n            conformers_trajs = []\n            for conf_fp in fps_confomers:\n                symbols, coords = read_xyz(conf_fp)\n                td_list = [self.copy().update_coords(c) for c in coords]\n                print(f\"\\t\\tCREST found {len(td_list)} conformers\")\n                conformers_trajs.extend(td_list)\n\n            for rot_fp in fps_rotamers:\n                symbols, coords = read_xyz(rot_fp)\n                td_list = [self.copy().update_coords(c) for c in coords]\n                print(f\"\\t\\tCREST found {len(td_list)} conformers\")\n                conformers_trajs.extend(td_list)\n\n        return conformers_trajs\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.atom_charge_iter","title":"<code>atom_charge_iter</code>  <code>property</code>","text":"<p>iter through atomic number and charge for every atom in OBmolecule</p>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.atomn","title":"<code>atomn</code>  <code>property</code>","text":"<p>returns number of atoms</p>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.coords","title":"<code>coords: np.array</code>  <code>property</code>","text":"<p>this return coordinates in Angstroms</p>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.molecule_rp","title":"<code>molecule_rp</code>  <code>property</code>","text":"<p>converts an openbabel molecule to a retropaths molecule</p>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.n_fragments","title":"<code>n_fragments: int</code>  <code>property</code>","text":"<p>computes the number of separate molecules in TDStructure</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of molecules in TDStructure</p>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.tc_client","title":"<code>tc_client</code>  <code>property</code>","text":"<p>stores chemcloud client</p>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.align_to_td","title":"<code>align_to_td(other_td)</code>","text":"<p>Aligns geometry to <code>other_td</code> to minimize RMSD. Uses Kabsch algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>other_td</code> <code>TDStructure</code> <p>structure to align to</p> required <p>Returns:</p> Name Type Description <code>TDStructure</code> <code>TDStructure</code> <p>aligned structure</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def align_to_td(self, other_td: TDStructure) -&gt; TDStructure:\n    \"\"\"Aligns geometry to `other_td` to minimize RMSD. Uses Kabsch algorithm.\n\n    Args:\n        other_td (TDStructure): structure to align to\n\n    Returns:\n        TDStructure: aligned structure\n    \"\"\"\n    __, new_coords = align_geom(other_td.coords, self.coords)\n    new_td = self.update_coords(new_coords)\n    return new_td\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.as_qcio_molecule","title":"<code>as_qcio_molecule()</code>","text":"<p>creates a qcio Molecule object from self</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def as_qcio_molecule(self):\n    \"\"\"\n    creates a qcio Molecule object from self\n    \"\"\"\n    d = {\n        \"symbols\": self.symbols,\n        \"geometry\": self.coords_bohr,\n        \"multiplicity\": self.spinmult,\n        \"charge\": self.charge,\n    }\n    tc_mol = TCMolecule(**d)\n    return tc_mol\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.compute_tc","title":"<code>compute_tc(program, calctype)</code>","text":"<p>uses ChemCloud to compute a property defined by <code>calctype</code>. See link</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def compute_tc(self, program: str, calctype: str):\n    \"\"\"\n    uses ChemCloud to compute a property defined by `calctype`.\n    See [link](https://mtzgroup.github.io/chemcloud-client/tutorial/compute/)\n    \"\"\"\n    prog_input = self._prepare_input(method=calctype)\n\n    future_result = self.tc_client.compute(\n        program, prog_input, queue=q, collect_files=True, propagate_wfn=True\n    )\n    output = future_result.get()\n\n    if output.success:\n        # if \"scr.geometry/c0\" in output.files.keys():\n        #     self.tc_c0 = output.files[\"scr.geometry/c0\"]\n        return output.return_result\n\n    else:\n        output.ptraceback\n        print(f\"TeraChem {calctype} failed.\")\n        return None\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.compute_tc_local","title":"<code>compute_tc_local(program, calctype, return_object=False)</code>","text":"<p>Uses qcop to compute properties. See link</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def compute_tc_local(\n    self, program: str, calctype: str, return_object: bool = False\n):\n    \"\"\"\n    Uses qcop to compute properties. See [link](https://github.com/coltonbh/qcop)\n    \"\"\"\n    prog_input = self._prepare_input(method=calctype)\n\n    output = qcop.compute(\n        program, prog_input, propagate_wfn=True, collect_files=True\n    )\n\n    if output.success:\n        # if \"scr.geometry/c0\" in output.files.keys():\n        #     self.tc_c0 = output.files[\"scr.geometry/c0\"]\n        if return_object:\n            return output\n        return output.return_result\n\n    else:\n        output.ptraceback\n        print(f\"TeraChem {calctype} failed.\")\n        if return_object:\n            return output\n        return None\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.energy_tc","title":"<code>energy_tc()</code>","text":"<p>energy for system using chemcloud</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def energy_tc(self):\n    \"\"\"\n    energy for system using chemcloud\n    \"\"\"\n    return self.compute_tc(ES_PROGRAM, \"energy\")\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.energy_tc_local","title":"<code>energy_tc_local()</code>","text":"<p>energy for system using local terachem</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def energy_tc_local(self):\n    \"\"\"\n    energy for system using local terachem\n    \"\"\"\n    return self.compute_tc_local(ES_PROGRAM, \"energy\")\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.energy_xtb","title":"<code>energy_xtb()</code>","text":"<p>returns XTB energy of TDStructure</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def energy_xtb(self) -&gt; float:\n    \"\"\"returns XTB energy of TDStructure\n    \"\"\"\n    try:\n        calc = Calculator(\n            get_method(\"GFN2-xTB\"),\n            self.atomic_numbers,\n            self.coords_bohr,\n            charge=self.charge,\n            uhf=self.spinmult - 1,\n        )\n        calc.set_verbosity(VERBOSITY_MUTED)\n        res = calc.singlepoint()\n        return res.get_energy()\n    except XTBException:\n        return None\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.from_ase_Atoms","title":"<code>from_ase_Atoms(atoms, charge, spinmult)</code>  <code>classmethod</code>","text":"<p>instantiates TDStructure from ASE Atoms object.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Atoms</code> <p>ASE Atoms object</p> required <code>charge</code> <code>int</code> <p>system charge</p> required <code>spinmult</code> <code>int</code> <p>system spin multiplicity</p> required Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>@classmethod\ndef from_ase_Atoms(cls, atoms: Atoms, charge: int, spinmult: int) -&gt; TDStructure:\n    \"\"\"\n    instantiates TDStructure from ASE Atoms object.\n\n    Args:\n        atoms: ASE Atoms object\n        charge: system charge\n        spinmult: system spin multiplicity\n\n    \"\"\"\n    atomT = np.asarray([from_number_to_element(x) for x in atoms.numbers])\n    string = write_xyz(atomT, atoms.get_positions())\n\n    with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w\", delete=False) as tmp:\n        tmp.write(string)\n\n    td = cls.from_xyz(tmp.name, charge=charge, spinmult=spinmult)\n    os.remove(tmp.name)\n    return td\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.from_cc_result","title":"<code>from_cc_result(result)</code>  <code>classmethod</code>","text":"<p>Build TDStructure from ChemCloud results object</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>ResultsType</code> <p>qcio results object see link</p> required Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>@classmethod\ndef from_cc_result(cls, result: ResultsType) -&gt; TDStructure:\n    \"\"\"\n    Build TDStructure from ChemCloud results object\n\n    Args:\n        result: qcio results object see [link](https://mtzgroup.github.io/chemcloud-client/)\n    \"\"\"\n    if hasattr(result, \"final_molecule\"):\n        mol = result.final_molecule\n    else:\n        mol = result.molecule\n\n    coords = mol.geometry\n    symbols = mol.symbols\n\n    td = TDStructure.from_coords_symbols(\n        coords=coords * (BOHR_TO_ANGSTROMS),\n        symbols=symbols,\n        tot_charge=int(mol.charge),\n        tot_spinmult=mol.multiplicity,\n    )\n\n    return td\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.from_mapped_smiles","title":"<code>from_mapped_smiles(smi, spinmult=1, charge=0)</code>  <code>classmethod</code>","text":"<p>creates a TDStructure from a mapped smiles format</p> <p>Parameters:</p> Name Type Description Default <code>smi</code> <code>str</code> <p>mapped smiles to use</p> required <code>spinmult</code> <code>int</code> <p>system spinmultiplicity</p> <code>1</code> <code>charge</code> <code>int</code> <p>system charge</p> <code>0</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>@classmethod\ndef from_mapped_smiles(cls, smi: str, spinmult: int = 1, charge: int = 0) -&gt; TDStructure:\n    \"\"\"\n    creates a TDStructure from a mapped smiles format\n\n    Args:\n        smi: mapped smiles to use\n        spinmult: system spinmultiplicity\n        charge: system charge\n    \"\"\"\n    mol = Molecule.from_mapped_smiles(smi)\n    obj = cls.from_molecule(mol, charge=charge, spinmult=spinmult)\n    return obj\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.from_molecule","title":"<code>from_molecule(rp_mol, charge=0, spinmult=1)</code>  <code>classmethod</code>","text":"<p>Instantiate object from <code>Molecule</code> object. see link</p> <p>Parameters:</p> Name Type Description Default <code>rp_mol</code> <code>Molecule</code> <p>Molecule object to build TDStructure from</p> required <code>charge</code> <code>int</code> <p>charge of molecule. Defaults to 0.</p> <code>0</code> <code>spinmult</code> <code>int</code> <p>spin multiplicity of molecule. Defaults to 1.</p> <code>1</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>@classmethod\ndef from_molecule(cls, rp_mol: Molecule, charge=0, spinmult=1) -&gt; TDStructure:\n    \"\"\"Instantiate object from `Molecule` object. see [link](https://mtzgroup.github.io/neb-dynamics/molecule/)\n\n    Args:\n        rp_mol (Molecule): Molecule object to build TDStructure from\n        charge (int, optional): charge of molecule. Defaults to 0.\n        spinmult (int, optional): spin multiplicity of molecule. Defaults to 1.\n\n    \"\"\"\n\n    d = {\"single\": 1, \"double\": 2, \"triple\": 3, \"aromatic\": 1.5}\n\n    obmol = openbabel.OBMol()\n\n    for i, _ in enumerate(rp_mol.nodes):\n\n        node = rp_mol.nodes[i]\n\n        atom_symbol = node[\"element\"]\n\n        atom_number = symbol_to_atomic_number(atom_symbol)\n        atom = openbabel.OBAtom()\n        atom.SetVector(0, 0, 0)\n        atom.SetAtomicNum(atom_number)\n        atom.SetFormalCharge(node[\"charge\"])\n        atom.SetId(i + 1)\n        obmol.AddAtom(atom)\n\n    for rp_atom1_id, rp_atom2_id in rp_mol.edges:\n        atom1_id = rp_atom1_id\n        atom2_id = rp_atom2_id\n        if type(atom1_id) is np.int64:\n            atom1_id = int(atom1_id)\n        if type(atom2_id) is np.int64:\n            atom2_id = int(atom2_id)\n\n        atom1 = obmol.GetAtom(atom1_id + 1)\n        atom2 = obmol.GetAtom(atom2_id + 1)\n\n        bond = openbabel.OBBond()\n        bond.SetBegin(atom1)\n        bond.SetEnd(atom2)\n\n        bond_order = rp_mol.edges[(rp_atom1_id, rp_atom2_id)][\"bond_order\"]\n        if d[bond_order] == 1.5:  # i.e., if an aromatic bond\n            bond.SetAromatic(True)\n            bond.SetBondOrder(4)\n        else:\n            bond.SetBondOrder(d[bond_order])\n\n        obmol.AddBond(bond)\n\n    arg = pybel.Molecule(obmol)\n    arg.make3D()\n    arg.localopt(\"uff\", steps=2000)\n    arg.localopt(\"gaff\", steps=2000)\n    arg.localopt(\"mmff94\", steps=2000)\n\n    obmol3D = arg.OBMol\n    obmol3D.SetTotalCharge(charge)\n    obmol3D.SetTotalSpinMultiplicity(spinmult)\n\n    return cls(obmol3D)\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.from_smiles","title":"<code>from_smiles(smi, tot_spinmult=1)</code>  <code>classmethod</code>","text":"<p>creates a TDStructure from a smiles format</p> <p>Parameters:</p> Name Type Description Default <code>smi</code> <code>str</code> <p>smiles to use</p> required <code>spinmult</code> <p>system spinmultiplicity</p> required Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>@classmethod\ndef from_smiles(cls, smi: str, tot_spinmult: int = 1):\n    \"\"\"\n    creates a TDStructure from a smiles format\n\n    Args:\n        smi: smiles to use\n        spinmult: system spinmultiplicity\n    \"\"\"\n    pybel_mol = pybel.readstring(\"smi\", smi)\n    pybel_mol.make3D()\n    pybel_mol.localopt(\"gaff\")\n    obmol = pybel_mol.OBMol\n    obmol.SetTotalSpinMultiplicity(tot_spinmult)\n    obj = cls(molecule_obmol=obmol)\n    obj.gum_mm_optimization()\n    return obj\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.from_xyz","title":"<code>from_xyz(fp, charge=0, spinmult=1)</code>  <code>classmethod</code>","text":"<p>creates a TDStructure from an xyz file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Path</code> <p>path to xyz file to open</p> required <code>spinmult</code> <p>system spinmultiplicity</p> <code>1</code> <code>charge</code> <p>system charge</p> <code>0</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>@classmethod\ndef from_xyz(cls, fp: Path, charge=0, spinmult=1) -&gt; TDStructure:\n    \"\"\"\n    creates a TDStructure from an xyz file\n\n    Args:\n        fp: path to xyz file to open\n        spinmult: system spinmultiplicity\n        charge: system charge\n    \"\"\"\n    if isinstance(fp, str):\n        fp = Path(fp)\n    # if \"OE_LICENSE\" not in os.environ:\n    obmol = load_obmol_from_fp(fp)\n    obmol.SetTotalCharge(charge)\n    obmol.SetTotalSpinMultiplicity(spinmult)\n    return cls(molecule_obmol=obmol)\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.gradient_tc","title":"<code>gradient_tc()</code>","text":"<p>gradient for system using chemcloud</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def gradient_tc(self):\n    \"\"\"\n    gradient for system using chemcloud\n    \"\"\"\n    return self.compute_tc(ES_PROGRAM, \"gradient\")\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.gradient_tc_local","title":"<code>gradient_tc_local()</code>","text":"<p>gradient for system using local terachem</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def gradient_tc_local(self):\n    \"\"\"\n    gradient for system using local terachem\n    \"\"\"\n    return self.compute_tc_local(ES_PROGRAM, \"gradient\")\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.gradient_xtb","title":"<code>gradient_xtb()</code>","text":"<p>return XTB gradient of TDStructure</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def gradient_xtb(self) -&gt; np.array:\n    \"\"\"\n    return XTB gradient of TDStructure\n    \"\"\"\n    calc = Calculator(\n        get_method(\"GFN2-xTB\"),\n        self.atomic_numbers,\n        self.coords_bohr,\n        charge=self.charge,\n        uhf=self.spinmult - 1,\n    )\n    calc.set_verbosity(VERBOSITY_MUTED)\n    res = calc.singlepoint()\n    return res.get_gradient() * BOHR_TO_ANGSTROMS\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.make_geom_and_inp_file","title":"<code>make_geom_and_inp_file(calculation='gradient')</code>","text":"<p>writes the geometry to disk and an input file. Returns the file paths to each</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def make_geom_and_inp_file(self, calculation=\"gradient\"):\n    \"\"\"\n    writes the geometry to disk and an input file.\n    Returns the file paths to each\n    \"\"\"\n\n    # make the geometry file\n    with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w+\", delete=False) as tmp:\n        self.to_xyz(tmp.name)\n\n    # make the tc input file\n    inp = f\"\"\"run {calculation}\n    coordinates {tmp.name}\n    method {self.tc_model_method}\n    basis {self.tc_model_basis}\n    charge {self.charge}\n    spinmult {self.spinmult}\n    scrdir {tmp.name[:-4]}\n    gpus  1\n    \"\"\"\n    with tempfile.NamedTemporaryFile(\n        suffix=\".in\", mode=\"w+\", delete=False\n    ) as tmp_inp:\n        tmp_inp.write(inp)\n\n    return tmp.name, tmp_inp.name\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.mm_optimization","title":"<code>mm_optimization(method='gaff', steps=2000)</code>","text":"<p>in place MM optimization</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def mm_optimization(self, method=\"gaff\", steps=2000):\n    \"\"\"\n    in place MM optimization\n    \"\"\"\n    pybel_mol = pybel.Molecule(self.molecule_obmol)\n    pybel_mol.localopt(method, steps=steps)\n    self.molecule_obmol = pybel_mol.OBMol\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.move_atom","title":"<code>move_atom(atom_index, new_x, new_y, new_z)</code>","text":"<p>this method moves the atom to the new coordinates</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def move_atom(self, atom_index, new_x, new_y, new_z):\n    \"\"\"\n    this method moves the atom to the new coordinates\n    \"\"\"\n    atom = self.molecule_obmol.GetAtom(atom_index + 1)\n    atom.SetVector(new_x, new_y, new_z)\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.run_tc_local","title":"<code>run_tc_local(calculation='energy', remove_all=True, return_object=False)</code>","text":"<p>run a local terachem calculation</p> <p>Parameters:</p> Name Type Description Default <code>calculation</code> <p>type of calculation to run. Supports 'energy', 'gradient', and 'minimize'</p> <code>'energy'</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def run_tc_local(self, calculation=\"energy\", remove_all=True, return_object=False):\n    \"\"\"\n    run a local terachem calculation\n\n    Args:\n        calculation: type of calculation to run. Supports 'energy', 'gradient', and 'minimize'\n    \"\"\"\n    # make the geometry file\n    with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w+\", delete=False) as tmp:\n        self.to_xyz(tmp.name)\n\n    # make the tc input file\n    inp = f\"\"\"run {calculation}\\ncoordinates {tmp.name}\\n\"\"\"\n    inp += self._tcpb_input_string()\n    inp += f\"\"\"scrdir {tmp.name[:-4]}\\nmaxiter 500\\n\"\"\"\n\n    if \"wf_guess\" in self.tc_kwds:\n        guess_path = self.tc_kwds[\"wf_guess\"]  # this must be a string\n        assert isinstance(\n            guess_path, str\n        ), f\"wavefunction guess in tc_kwds needs to be a string, not a {type(guess_path)}\"\n        inp += f\"\\nguess {guess_path}\"\n\n    with tempfile.NamedTemporaryFile(\n        suffix=\".in\", mode=\"w+\", delete=False\n    ) as tmp_inp:\n        tmp_inp.write(inp)\n\n    # run the tc calc\n    with tempfile.NamedTemporaryFile(\n        suffix=\".out\", mode=\"w+\", delete=False\n    ) as tmp_out:\n        out = subprocess.run(\n            [f\"terachem {tmp_inp.name}\"], shell=True, capture_output=True\n        )\n        tmp_out.write(out.stdout.decode())\n\n    if calculation == \"minimize\":\n        result = run_tc_local_optimization(\n            td=self, tmp=tmp, return_optim_traj=return_object\n        )\n\n    else:\n        result_obj = parse(tmp_out.name, program=\"terachem\")\n        if calculation == \"energy\":\n            result = result_obj.energy\n        elif calculation == \"gradient\":\n            result = result_obj.gradient\n        if return_object:\n            result = result_obj\n        else:\n            result = result_obj.return_result\n\n    # remove everything\n    if remove_all:\n        Path(tmp.name).unlink()\n        Path(tmp_inp.name).unlink()\n        Path(tmp_out.name).unlink()\n\n        shutil.rmtree(tmp.name[:-4])  # delete scratch dir\n    elif not remove_all:\n        print(f\"{tmp.name=} {tmp_inp.name=} {tmp_out.name=}\")\n    return result\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.set_charge","title":"<code>set_charge(charge)</code>","text":"<p>sets charge of TDStructure</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def set_charge(self, charge):\n    \"\"\"\n    sets charge of TDStructure\n    \"\"\"\n    self.molecule_obmol.SetTotalCharge(charge)\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.set_spinmult","title":"<code>set_spinmult(tot_spinmult)</code>","text":"<p>sets spin multiplicity of TDStructure</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def set_spinmult(self, tot_spinmult):\n    \"\"\"\n    sets spin multiplicity of TDStructure\n    \"\"\"\n    self.molecule_obmol.SetTotalSpinMultiplicity(tot_spinmult)\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.tc_freq_calculation","title":"<code>tc_freq_calculation()</code>","text":"<p>returns frequences from hessian calculation using bigchem</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def tc_freq_calculation(self):\n    \"\"\"\n    returns frequences from hessian calculation using bigchem\n    \"\"\"\n    freqs, _ = self.tc_freq_nma_calculation()\n    return freqs\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.tc_geom_optimization","title":"<code>tc_geom_optimization(method='minima')</code>","text":"<p>geometry optimization for system using chemcloud</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>whether to do a \"minima\" or \"ts\" optimization.             uses <code>geometric</code> to carry out optimizations.</p> <code>'minima'</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def tc_geom_optimization(self, method=\"minima\"):\n    \"\"\"\n    geometry optimization for system using chemcloud\n\n    Args:\n        method: whether to do a \"minima\" or \"ts\" optimization. \\\n        uses `geometric` to carry out optimizations.\n    \"\"\"\n    if method == \"minima\":\n        opt_input = self._prepare_input(method=\"optimization\")\n    elif method == \"ts\":\n        opt_input = self._prepare_input(method=\"transition_state\")\n    else:\n        raise ValueError(\n            f\"Unrecognized method: {method}. Use either: 'minima', or 'ts'\"\n        )\n    pwfn_bool = ES_PROGRAM == \"terachem\"\n    future_result = self.tc_client.compute(\n        \"geometric\",\n        opt_input,\n        queue=q,\n        # this cannot be true is using psi4 for some reason...\n        propagate_wfn=pwfn_bool,\n    )\n    output = future_result.get()\n    result = output.results\n\n    if output.success:\n        print(\"Optimization succeeded!\")\n    else:\n        print(\"Optimization failed!\")\n        output.ptraceback\n\n    coords = result.final_molecule.geometry\n    symbols = result.final_molecule.symbols\n    td_opt_tc = TDStructure.from_coords_symbols(\n        coords=coords * (1 / ANGSTROM_TO_BOHR),\n        symbols=symbols,\n        tot_charge=int(result.final_molecule.charge),\n        tot_spinmult=result.final_molecule.multiplicity,\n    )\n\n    td_opt_tc.update_tc_parameters(self)\n\n    return td_opt_tc\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.tc_local_geom_optimization","title":"<code>tc_local_geom_optimization(method='minima')</code>","text":"<p>geometry optimization for system using local terachem</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>whether to do a \"minima\" or \"ts\" optimization.             uses <code>geometric</code> in <code>qcop</code> to carry out optimizations.</p> <code>'minima'</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def tc_local_geom_optimization(self, method=\"minima\"):\n    \"\"\"\n    geometry optimization for system using local terachem\n\n    Args:\n        method: whether to do a \"minima\" or \"ts\" optimization. \\\n        uses `geometric` in `qcop` to carry out optimizations.\n    \"\"\"\n    if method == \"minima\":\n        # opt_input = self._prepare_input(method=\"optimization\")\n        return self.run_tc_local(calculation=\"minimize\")\n    elif method == \"ts\":\n        opt_input = self._prepare_input(method=\"transition_state\")\n    else:\n        raise ValueError(\n            f\"Unrecognized method: {method}. Use either: 'minima', or 'ts'\"\n        )\n\n    output = qcop.compute(\n        \"geometric\",\n        opt_input,\n        queue=q,\n        # this cannot be true is using psi4 for some reason...\n        propagate_wfn=True,\n    )\n\n    result = output.results\n\n    if output.success:\n        print(\"Optimization succeeded!\")\n    else:\n        print(\"Optimization failed!\")\n        output.ptraceback\n\n    coords = result.final_molecule.geometry\n    symbols = result.final_molecule.symbols\n    td_opt_tc = TDStructure.from_coords_symbols(\n        coords=coords * (1 / ANGSTROM_TO_BOHR),\n        symbols=symbols,\n        tot_charge=int(result.final_molecule.charge),\n        tot_spinmult=result.final_molecule.multiplicity,\n    )\n\n    td_opt_tc.update_tc_parameters(self)\n\n    return td_opt_tc\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.tc_local_ts_optimization","title":"<code>tc_local_ts_optimization(**kwargs)</code>","text":"<p>geometry optimization for system using local terachem. Will attempt a transition state search.</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def tc_local_ts_optimization(self, **kwargs):\n    \"\"\"\n    geometry optimization for system using local terachem.\n    Will attempt a transition state search.\n    \"\"\"\n    return self.run_tc_local(\n        calculation=\"ts\",\n        method=self.tc_model_method,\n        basis=self.tc_model_basis,\n        **kwargs,\n    )\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.tc_nma_calculation","title":"<code>tc_nma_calculation()</code>","text":"<p>returns normal modes from hessian calculation using bigchem</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def tc_nma_calculation(self):\n    \"\"\"\n    returns normal modes from hessian calculation using bigchem\n    \"\"\"\n    _, nmas = self.tc_freq_nma_calculation()\n\n    nmas_flat = nmas\n    nmas_reshaped = []\n    for nma in nmas_flat:\n        nma_arr = np.array(nma)\n        nmas_reshaped.append(nma_arr.reshape(self.coords.shape))\n\n    return nmas_reshaped\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.to_ASE_atoms","title":"<code>to_ASE_atoms()</code>","text":"<p>converts TDStructure into <code>Atoms</code> object for usage with ASE.</p> <p>Returns:</p> Name Type Description <code>Atoms</code> <code>Atoms</code> <p>TDStructure converted to Atoms object from ASE</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def to_ASE_atoms(self) -&gt; Atoms:\n    \"\"\"converts TDStructure into `Atoms` object for usage with ASE.\n\n    Returns:\n        Atoms: TDStructure converted to Atoms object from ASE\n    \"\"\"\n    # XTB api is summing the initial charges from the ATOM object.\n    # it returns a vector of charges (maybe Mulliken), but to initialize the calculation,\n    # it literally sums this vector up. So we create a zero vector (natoms long) and we\n    # modify the charge of the first atom to be total charge.\n    charges = np.zeros(self.atomn)\n    charges[0] = self.charge\n\n    spins = np.zeros(self.atomn)\n    spins[0] = self.spinmult - 1\n\n    atoms = Atoms(\n        symbols=self.symbols.tolist(),\n        positions=self.coords,\n        charges=charges,\n        magmoms=spins,\n    )\n    return atoms\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.to_pdb","title":"<code>to_pdb(fn)</code>","text":"<p>Writes molecule to PDB format</p> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def to_pdb(self, fn: Path) -&gt; None:\n    \"\"\"Writes molecule to PDB format\n    \"\"\"\n    mol_pybel = pybel.Molecule(self.molecule_obmol)\n    mol_pybel.write(format=\"pdb\", filename=str(fn), overwrite=True)\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.update_coords","title":"<code>update_coords(coords)</code>","text":"<p>updates the coordinates of the TDStructure to be those of <code>coords</code>.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>array</code> <p>coords to update TDStructure to</p> required Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def update_coords(self, coords: np.array) -&gt; TDStructure:\n    \"\"\"updates the coordinates of the TDStructure to be those of `coords`.\n\n    Args:\n        coords: coords to update TDStructure to\n\n    \"\"\"\n    np.testing.assert_array_equal(coords.shape, self.coords.shape,\n                                  err_msg=f\"Input array shape ({coords.shape}) does not match \\\n                                    existing shape ({self.coords.shape})\")\n\n    string = write_xyz(self.symbols, coords)\n\n    with tempfile.NamedTemporaryFile(suffix=\".xyz\", mode=\"w\", delete=False) as tmp:\n        tmp.write(string)\n\n    td = TDStructure.from_xyz(\n        tmp.name, charge=self.charge, spinmult=self.spinmult\n    )\n    os.remove(tmp.name)\n    return td\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.update_tc_parameters","title":"<code>update_tc_parameters(td_ref)</code>","text":"<p>updates the TC parameters INPLACE for <code>self</code> from a reference TDStructure.</p> <p>Warning</p> <p>This update is done INPLACE.</p> <p>Parameters:</p> Name Type Description Default <code>td_ref</code> <code>TDStructure</code> <p>reference TDStructure</p> required Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def update_tc_parameters(self, td_ref: TDStructure) -&gt; None:\n    \"\"\"\n    updates the TC parameters INPLACE for `self` from a reference TDStructure.\n\n    !!! Warning\n        This update is done INPLACE.\n\n    Args:\n        td_ref: reference TDStructure\n    \"\"\"\n    tc_model_method = td_ref.tc_model_method\n    tc_model_basis = td_ref.tc_model_basis\n    tc_kwds = td_ref.tc_kwds.copy()\n    tc_geom_opt_kwds = td_ref.tc_geom_opt_kwds.copy()\n\n    self.tc_model_method = tc_model_method\n    self.tc_model_basis = tc_model_basis\n    self.tc_kwds = tc_kwds\n    self.tc_geom_opt_kwds = tc_geom_opt_kwds\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.update_tc_parameters_from_inpfile","title":"<code>update_tc_parameters_from_inpfile(file_path, read_in_charges_spinmult=False)</code>","text":"<p>updates TC parameters from a terachem input file. Returns a COPY</p> <p>Warning</p> <p>This update is NOT done in place. An updated copy is returned.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>file path to Terachem input file</p> required <code>read_in_charges_spinmult</code> <code>bool</code> <p>Whether to replace TDStructure <code>charge</code>                 and <code>spinmult</code> values with whatever is specified in the input file.</p> <code>False</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def update_tc_parameters_from_inpfile(self, file_path: str, read_in_charges_spinmult: bool = False) -&gt; TDStructure:\n    \"\"\"updates TC parameters from a terachem input file. Returns a COPY\n\n    !!! Warning\n        This update is NOT done in place. An updated copy is returned.\n\n    Args:\n        file_path: file path to Terachem input file\n        read_in_charges_spinmult: Whether to replace TDStructure `charge` \\\n            and `spinmult` values with whatever is specified in the input file.\n    \"\"\"\n    td_copy = self.copy()\n\n    method, basis, charge, spinmult, inp_kwds = _load_info_from_tcin(\n        file_path)\n    if charge and read_in_charges_spinmult:\n        print(\n            f\"Warning!: Setting charge to what is specified in {file_path}\")\n        td_copy.set_charge(charge)\n\n    if spinmult and read_in_charges_spinmult:\n        print(\n            f\"Warning!: Setting multiplicity to what is specified in {file_path}\")\n        td_copy.set_spinmult(spinmult)\n\n    td_copy.tc_model_method = method\n    td_copy.tc_model_basis = basis\n    td_copy.tc_kwds = inp_kwds\n\n    return td_copy\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.xtb_geom_optimization","title":"<code>xtb_geom_optimization(return_traj=False)</code>","text":"<p>Run geometry optimization using XTB Calculator in ASE.</p> <p>Parameters:</p> Name Type Description Default <code>return_traj</code> <p>Whether to return a list of tdstructures of the optimziation trajectory</p> <code>False</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def xtb_geom_optimization(self, return_traj=False) -&gt; Union[List[TDStructure], TDStructure]:\n    \"\"\"\n    Run geometry optimization using XTB Calculator in ASE.\n\n    Args:\n        return_traj: Whether to return a list of tdstructures of the optimziation trajectory\n    \"\"\"\n\n    tmp = tempfile.NamedTemporaryFile(\n        suffix=\".traj\", mode=\"w+\", delete=False)\n\n    atoms = self.to_ASE_atoms()\n    # print(tmp.name)\n\n    atoms.calc = XTB(method=\"GFN2-xTB\", accuracy=0.001)\n    # opt = LBFGSLineSearch(atoms, logfile=None, trajectory=tmp.name)\n    opt = SciPyFminCG(atoms, logfile=None, trajectory=tmp.name)\n    # opt = Sella(atoms, logfile=None, trajectory=tmp.name)\n    # opt = LBFGS(atoms, logfile=None, trajectory='/tmp/log.traj')\n    # opt = FIRE(atoms, logfile=None)\n    opt.run(fmax=0.01)\n    # opt.run(fmax=0.5)\n\n    aT = ASETraj(tmp.name)\n    traj_list = []\n    for i, _ in enumerate(aT):\n        traj_list.append(\n            TDStructure.from_ase_Atoms(\n                aT[i], charge=self.charge, spinmult=self.spinmult\n            )\n        )\n    traj = [td.update_tc_parameters(self) for td in traj_list]\n\n    Path(tmp.name).unlink()\n    if return_traj:\n        print(\"len opt traj: \", len(traj))\n        return traj\n    else:\n        return traj[-1]\n</code></pre>"},{"location":"tdstructure/#neb_dynamics.tdstructure.TDStructure.xtb_sella_geom_optimization","title":"<code>xtb_sella_geom_optimization(return_traj=False)</code>","text":"<p>Use SELLA and XTB to minimize the geometry.</p> <p>Parameters:</p> Name Type Description Default <code>return_traj</code> <p>Whether to return a list of tdstructures of the optimziation trajectory</p> <code>False</code> Source code in <code>neb_dynamics/tdstructure.py</code> <pre><code>def xtb_sella_geom_optimization(self, return_traj=False):\n    \"\"\"\n    Use SELLA and XTB to minimize the geometry.\n\n    Args:\n        return_traj: Whether to return a list of tdstructures of the optimziation trajectory\n    \"\"\"\n    tmp = tempfile.NamedTemporaryFile(\n        suffix=\".traj\", mode=\"w+\", delete=False)\n\n    atoms = self.to_ASE_atoms()\n    # print(tmp.name)\n\n    atoms.calc = XTB(method=\"GFN2-xTB\", accuracy=0.001)\n    opt = Sella(atoms, logfile=None, trajectory=tmp.name)\n    opt.run(fmax=0.01)\n\n    aT = ASETraj(tmp.name)\n    traj_list = []\n    for i, _ in enumerate(aT):\n        traj_list.append(\n            TDStructure.from_ase_Atoms(\n                aT[i], charge=self.charge, spinmult=self.spinmult\n            )\n        )\n    traj = [td.update_tc_parameters(self) for td in traj_list]\n\n    Path(tmp.name).unlink()\n    if return_traj:\n        print(\"len opt traj: \", len(traj))\n        return traj\n    else:\n        return traj[-1]\n</code></pre>"}]}