{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NEB Dynamics Documentation","text":"<p>Welcome to the NEB Dynamics documentation! This software package provides tools for running automated minimum energy path (MEP) minimizations using the Nudged Elastic Band (NEB) method and its variants.</p>"},{"location":"#overview","title":"Overview","text":"<p>NEB Dynamics is designed to: - Find transition states and reaction paths between chemical structures - Automatically split complex reaction pathways into elementary steps - Support multiple electronic structure engines (ChemCloud, QCOP, ASE-based calculators) - Provide geodesic interpolation for generating initial path guesses</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install \"git+https://github.com/mtzgroup/neb-dynamics.git\"\n</code></pre>"},{"location":"#chemcloud-setup-recommended","title":"ChemCloud Setup (Recommended)","text":"<p>NEB Dynamics uses ChemCloud for electronic structure calculations. You'll need:</p> <ol> <li>Sign up at https://chemcloud.mtzlab.com/signup</li> <li>Configure authentication (choose one option below):</li> </ol> <pre><code># Option 1: Run setup_profile() - writes credentials to ~/.chemcloud/credentials\npython -c \"from chemcloud import setup_profile; setup_profile()\"\n\n# Option 2: Use environment variables (for memory-only auth)\nexport CHEMCLOUD_USERNAME=your_email@chemcloud.com\nexport CHEMCLOUD_PASSWORD=your_password\n\n# Option 3: Custom server (if using a different domain)\nexport CHEMCLOUD_DOMAIN=\"https://your-server-url.com\"\n</code></pre>"},{"location":"#tips","title":"Tips","text":"<ul> <li>For local calculations, you can also use ASE with machine learning potentials</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import numpy as np\nfrom qcio import Structure\nfrom neb_dynamics import StructureNode, NEBInputs, ChainInputs\nfrom neb_dynamics.engines.qcop import QCOPEngine\nfrom neb_dynamics.neb import NEB\nimport neb_dynamics.chainhelpers as ch\nfrom neb_dynamics import Chain\nfrom neb_dynamics.optimizers.cg import ConjugateGradient\n\n# 1. Define initial and final structures using embedded XYZ data\nstart_xyz = \"\"\"17\nFrame 0\n C          0.885440409184        2.102076768875        0.627821743488\n C          0.841612815857        1.115651130676       -0.247040778399\n C         -0.420807182789        0.556873917580       -0.838685691357\n O         -0.430870711803        0.798001468182       -2.239025592804\n C         -0.522329509258       -0.964021146297       -0.644988238811\n C         -0.715307652950       -1.349323630333        0.785972416401\n C          0.097422197461       -2.135773420334        1.466876506805\n H         -0.267592728138        1.735007524490       -2.391090631485\n H         -1.386946558952       -1.296320080757       -1.227010726929\n H          0.993258416653       -2.552916049957        1.031124353409\n H         -0.008914750069        2.554719924927        1.029638171196\n H          1.820721507072        2.502734899521        0.982666194439\n H          1.748645901680        0.692936420441       -0.660514891148\n H         -1.296261906624        1.040292620659       -0.372635990381\n H          0.376222431660       -1.434682250023       -1.046772599220\n H         -1.611668467522       -0.956238925457        1.253052473068\n H         -0.102624341846       -2.409019231796        2.490613460541\n\"\"\"\n\nend_xyz = \"\"\"17\nFrame 29\n C          0.576232671738        0.921668708324        0.825146675110\n C          0.811691701412        1.315650582314       -0.631796598434\n C         -0.290672153234        0.930290937424       -1.571661710739\n O         -0.139186233282        0.584553778172       -2.709024667740\n C         -1.166546344757       -1.861497998238       -0.220005810261\n C         -0.774998486042       -1.183089017868        0.841198801994\n C          0.589584112167       -0.601971745491        1.032947182655\n H          0.880913138390        2.407624959946       -0.707833826542\n H         -2.171884059906       -2.235154390335       -0.311172336340\n H          1.294490098953       -1.047748923302        0.330671131611\n H         -0.374946832657        1.333065629005        1.164748311043\n H          1.358177542686        1.381788730621        1.429385662079\n H          1.752718806267        0.898995816708       -0.990877032280\n H         -1.302031993866        1.039528012276       -1.137167930603\n H         -0.504405736923       -2.070925474167       -1.043461441994\n H         -1.469262003899       -0.993297398090        1.650624632835\n H          0.930125653744       -0.819482147694        2.048279047012\n\"\"\"\n\n# Load structures from XYZ strings\nstart = Structure.from_xyz(start_xyz)\nend = Structure.from_xyz(end_xyz)\n\n# 2. Create nodes\nstart_node = StructureNode(structure=start)\nend_node = StructureNode(structure=end)\n\n# 3. Set up engine using ChemCloud\neng = QCOPEngine(compute_program=\"chemcloud\")\n\n# 4. Optimize endpoints\nstart_opt = eng.compute_geometry_optimization(start_node)\nend_opt = eng.compute_geometry_optimization(end_node)\n\n# 5. Create initial chain using geodesic interpolation\nchain = Chain.model_validate({\n    'nodes': [start_opt[-1], end_opt[-1]],\n    'parameters': ChainInputs(k=0.1, delta_k=0.09)\n})\ninitial_chain = ch.run_geodesic(chain, nimages=15)\n\n# 6. Run NEB optimization\nopt = ConjugateGradient(timestep=0.5)\nnbi = NEBInputs(v=True)\nn = NEB(initial_chain=initial_chain, parameters=nbi, optimizer=opt, engine=eng)\nresults = n.optimize_chain()\n\n# 7. Visualize results\nn.plot_opt_history(1)\nch.visualize_chain(n.optimized)\n</code></pre>"},{"location":"about/","title":"About NEB Dynamics","text":"<p>NEB Dynamics is a tool for running autosplitting MEP minimizations.</p>"},{"location":"api/","title":"API Reference","text":"<p>This section provides detailed API documentation for the main classes and functions.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#neb","title":"NEB","text":"<p>Main class for Nudged Elastic Band calculations.</p> <pre><code>from neb_dynamics.neb import NEB\n</code></pre> <p>::: neb_dynamics.neb.NEB</p>"},{"location":"api/#msmep","title":"MSMEP","text":"<p>Multi-Step Minimum Energy Path calculator for handling complex reactions.</p> <pre><code>from neb_dynamics import MSMEP\n</code></pre> <p>::: neb_dynamics.msmep.MSMEP</p>"},{"location":"api/#chain","title":"Chain","text":"<p>Container for a pathway consisting of multiple images.</p> <pre><code>from neb_dynamics import Chain\n</code></pre> <p>::: neb_dynamics.chain.Chain</p>"},{"location":"api/#structurenode","title":"StructureNode","text":"<p>A node containing a molecular structure.</p> <pre><code>from neb_dynamics import StructureNode\n</code></pre> <p>::: neb_dynamics.nodes.node.StructureNode</p>"},{"location":"api/#input-classes","title":"Input Classes","text":""},{"location":"api/#nebinputs","title":"NEBInputs","text":"<p>Configuration for NEB optimization.</p> <pre><code>from neb_dynamics.inputs import NEBInputs\n</code></pre> <p>::: neb_dynamics.inputs.NEBInputs</p>"},{"location":"api/#chaininputs","title":"ChainInputs","text":"<p>Configuration for chain behavior.</p> <pre><code>from neb_dynamics.inputs import ChainInputs\n</code></pre> <p>::: neb_dynamics.inputs.ChainInputs</p>"},{"location":"api/#giinputs","title":"GIInputs","text":"<p>Configuration for geodesic interpolation.</p> <pre><code>from neb_dynamics.inputs import GIInputs\n</code></pre> <p>::: neb_dynamics.inputs.GIInputs</p>"},{"location":"api/#runinputs","title":"RunInputs","text":"<p>Complete configuration for MSMEP calculations.</p> <pre><code>from neb_dynamics.inputs import RunInputs\n</code></pre> <p>::: neb_dynamics.inputs.RunInputs</p>"},{"location":"api/#engines","title":"Engines","text":""},{"location":"api/#engine-abstract-base","title":"Engine (Abstract Base)","text":"<p>Base class for all engines.</p> <pre><code>from neb_dynamics.engines import Engine\n</code></pre> <p>::: neb_dynamics.engines.engine.Engine</p>"},{"location":"api/#qcopengine","title":"QCOPEngine","text":"<p>Engine using QCOP for electronic structure calculations.</p> <pre><code>from neb_dynamics.engines import QCOPEngine\n</code></pre> <p>::: neb_dynamics.engines.qcop.QCOPEngine</p>"},{"location":"api/#aseengine","title":"ASEEngine","text":"<p>Engine using ASE calculators.</p> <pre><code>from neb_dynamics.engines import ASEEngine\n</code></pre> <p>::: neb_dynamics.engines.ase.ASEEngine</p>"},{"location":"api/#optimizers","title":"Optimizers","text":""},{"location":"api/#optimizer-abstract-base","title":"Optimizer (Abstract Base)","text":"<p>Base class for optimizers.</p> <pre><code>from neb_dynamics.optimizers import Optimizer\n</code></pre>"},{"location":"api/#velocityprojectedoptimizer","title":"VelocityProjectedOptimizer","text":"<p>VPO optimizer with velocity projection.</p> <pre><code>from neb_dynamics.optimizers.vpo import VelocityProjectedOptimizer\n</code></pre>"},{"location":"api/#conjugategradient","title":"ConjugateGradient","text":"<p>Conjugate gradient optimizer.</p> <pre><code>from neb_dynamics.optimizers.cg import ConjugateGradient\n</code></pre>"},{"location":"api/#lbfgs","title":"LBFGS","text":"<p>Limited-memory BFGS optimizer.</p> <pre><code>from neb_dynamics.optimizers.lbfgs import LBFGS\n\n## Helper Functions\n\n### chainhelpers\n\nUtility functions for chain manipulation and visualization.\n\n```python\nimport neb_dynamics.chainhelpers as ch\n</code></pre> <p>Common functions:</p> <ul> <li><code>ch.run_geodesic()</code> - Create chain using geodesic interpolation</li> <li><code>ch.visualize_chain()</code> - Visualize chain in 3D</li> <li><code>ch.compute_NEB_gradient()</code> - Calculate NEB gradient</li> <li><code>ch.get_g_perps()</code> - Get perpendicular gradients</li> <li><code>ch._get_ind_minima()</code> - Find indices of minima in chain</li> </ul>"},{"location":"cli/","title":"Command Line Interface","text":"<p>NEB Dynamics provides a command-line interface (CLI) via the <code>mepd</code> command. This is installed automatically when you install the package.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>After installing NEB Dynamics, the CLI is available:</p> <pre><code>pip install \"git+https://github.com/mtzgroup/neb-dynamics.git\"\nmepd --help\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#run","title":"run","text":"<p>Run NEB or MSMEP calculations from the command line.</p> <pre><code>mepd run --start START.xyz --end END.xyz --inputs inputs.toml\n</code></pre> <p>Options:</p> Option Description <code>--start</code>, <code>-s</code> Path to start structure file (XYZ or .qcio), or a SMILES string with <code>--use-smiles</code> <code>--end</code>, <code>-e</code> Path to end structure file, or SMILES with <code>--use-smiles</code> <code>--geometries</code> Path to file containing an approximate path (multiple structures) <code>--inputs</code>, <code>-i</code> Path to RunInputs TOML file <code>--use-smiles</code> Use SMILES strings for start/end instead of files <code>--use-tsopt</code> Run transition state optimization on each TS guess <code>--minimize-ends</code> Minimize endpoint geometries before NEB <code>--recursive</code> Run autosplitting MSMEP <code>--name</code> Custom name for output files <code>--charge</code> Molecular charge (default: 0) <code>--multiplicity</code> Spin multiplicity (default: 1) <code>--create-irc</code> Run IRC after TS optimization <code>--use-bigchem</code> Use ChemCloud for Hessian calculations in TS optimization <p>Example:</p> <pre><code># Basic NEB calculation\nmepd run --start reactant.xyz --product.xyz --inputs inputs.toml\n\n# Using SMILES\nmepd run --start \"CBr\" --end \"CO\" --use-smiles --inputs inputs.toml\n\n# Autosplitting MSMEP\nmepd run --start start.xyz --end end.xyz --recursive --inputs inputs.toml\n\n# With TS optimization and IRC\nmepd run --start start.xyz --end end.xyz --use-tsopt --create-irc --inputs inputs.toml\n</code></pre>"},{"location":"cli/#run-refine","title":"run-refine","text":"<p>Run a two-stage refinement workflow: 1. run a cheap discovery MEP/MSMEP, 2. reoptimize discovered minima at an expensive level, 3. run expensive pair-path minimizations between adjacent refined minima.</p> <pre><code>mepd run-refine PATH.xyz --inputs expensive.toml --cheap-inputs cheap.toml\n</code></pre> <p>Options:</p> Option Description <code>--start</code>, <code>-s</code> Path to start structure file (or SMILES with <code>--use-smiles</code>) <code>--end</code>, <code>-e</code> Path to end structure file (or SMILES with <code>--use-smiles</code>) <code>geometries</code> Path to approximate path file (same convention as <code>run</code>) <code>--inputs</code>, <code>-i</code> Required expensive RunInputs TOML <code>--cheap-inputs</code>, <code>-ci</code> Optional cheap RunInputs TOML (defaults to <code>--inputs</code>) <code>--recursive</code> Use recursive MSMEP in cheap stage and expensive pair stage <code>--recycle-nodes</code> Seed expensive pair runs with cheap-path nodes instead of fresh interpolation <code>--minimize-ends</code> Minimize endpoints at cheap level before discovery <code>--name</code> Prefix for output files <code>--charge</code> Molecular charge (default: 0) <code>--multiplicity</code> Spin multiplicity (default: 1) <p>Example:</p> <pre><code>mepd run-refine examples/oxycope.xyz \\\n  -i expensive_chemcloud_terachem.toml \\\n  -ci cheap_chemcloud_crest.toml \\\n  --recursive \\\n  --recycle-nodes \\\n  --name oxycope_refine\n</code></pre> <p>Outputs:</p> <ul> <li><code>&lt;name&gt;_cheap.xyz</code></li> <li><code>&lt;name&gt;_cheap_msmep/</code> (recursive cheap stage)</li> <li><code>&lt;name&gt;_refined_minima.xyz</code></li> <li><code>&lt;name&gt;_refined_pairs/</code></li> <li><code>&lt;name&gt;_refined.xyz</code></li> </ul>"},{"location":"cli/#ts","title":"ts","text":"<p>Optimize a transition state structure.</p> <pre><code>mepd ts geometry.xyz --inputs inputs.toml\n</code></pre> <p>Options:</p> Option Description <code>geometry</code> Path to geometry file to optimize (required) <code>--inputs</code>, <code>-i</code> Path to RunInputs TOML file <code>--name</code> Custom name for output files <code>--charge</code> Molecular charge (default: 0) <code>--multiplicity</code> Spin multiplicity (default: 1) <code>--bigchem</code> Use ChemCloud for TS optimization <p>Example:</p> <pre><code>mepd ts ts_guess.xyz --inputs inputs.toml\nmepd ts ts_guess.xyz --bigchem --name my_ts\n</code></pre>"},{"location":"cli/#pseuirc","title":"pseuirc","text":"<p>Compute pseudo-IRC path from a transition state.</p> <pre><code>mepd pseuirc ts_geometry.xyz --inputs inputs.toml\n</code></pre> <p>Options:</p> Option Description <code>geometry</code> Path to TS geometry file (required) <code>--inputs</code>, <code>-i</code> Path to RunInputs TOML file <code>--name</code> Custom name for output files <code>--charge</code> Molecular charge (default: 0) <code>--multiplicity</code> Spin multiplicity (default: 1) <code>--dr</code> Displacement distance in Angstroms (default: 1.0) <p>Example:</p> <pre><code>mepd pseuirc ts_guess.xyz --dr 0.5\n</code></pre>"},{"location":"cli/#make-default-inputs","title":"make-default-inputs","text":"<p>Create a default RunInputs TOML file.</p> <pre><code>mepd make-default-inputs --name inputs.toml\n</code></pre> <p>Options:</p> Option Description <code>--name</code> Path to output TOML file <code>--path-min-method</code>, <code>-pmm</code> Path minimization method: <code>neb</code> or <code>fneb</code> (default: neb)"},{"location":"cli/#run-netgen","title":"run-netgen","text":"<p>Run network generation for multiple conformer pairs.</p> <pre><code>mepd run-netgen --start reactants.xyz --end products.xyz --inputs inputs.toml\n</code></pre> <p>Options:</p> Option Description <code>--start</code> Path to reactant conformers file <code>--end</code> Path to product conformers file <code>--inputs</code>, <code>-i</code> Path to RunInputs TOML file <code>--name</code> Custom name for output files <code>--charge</code> Molecular charge (default: 0) <code>--multiplicity</code> Spin multiplicity (default: 1) <code>--max-pairs</code> Maximum number of pairs to process (default: 500) <code>--minimize-ends</code> Minimize endpoint geometries before NEB"},{"location":"cli/#make-netgen-summary","title":"make-netgen-summary","text":"<p>Create a summary plot and network from network generation results.</p> <pre><code>mepd make-netgen-summary --directory ./results\n</code></pre> <p>Options:</p> Option Description <code>--directory</code> Path to data directory containing network results <code>--inputs</code>, <code>-i</code> Path to RunInputs TOML file <code>--name</code> Name of pot and summary file (default: netgen) <code>--verbose</code> Enable verbose output"},{"location":"cli/#make-netgen-path","title":"make-netgen-path","text":"<p>Create a path through a network.</p> <pre><code>mepd make-netgen-path --name network.json --inds 0 5 10\n</code></pre> <p>Options:</p> Option Description <code>--name</code> Path to JSON file containing network object <code>--inds</code> Sequence of node indices to create path for"},{"location":"cli/#input-file-format","title":"Input File Format","text":"<p>The CLI uses TOML input files. See Input Parameters for details.</p> <p>Example input file:</p> <pre><code>[RunInputs]\nengine_name = \"qcop\"\nprogram = \"xtb\"\npath_min_method = \"NEB\"\n\n[program_kwds]\n[program_kwds.model]\nmethod = \"GFN2xTB\"\n\n[chain_inputs]\nk = 0.1\ndelta_k = 0.09\n\n[gi_inputs]\nnimages = 15\nfriction = 0.001\nnudge = 0.1\n\n[path_min_inputs]\nv = true\nmax_steps = 500\n\n[optimizer_kwds]\ntimestep = 0.5\n</code></pre>"},{"location":"cli/#mlpgi-toml-example","title":"MLPGI TOML Example","text":"<pre><code>engine_name = \"chemcloud\"\nprogram = \"crest\"\npath_min_method = \"mlpgi\"\n\n[path_min_inputs]\nbackend = \"fairchem\"\ndevice = \"cpu\"\ndtype = \"float32\"\nmodel_path = \"esen_sm_conserving_all.pt\"\nmodel_repo = \"facebook/OMol25\"\nauto_download_model = true\n</code></pre> <p>If auto-download is enabled and the model repo is gated, authenticate first:</p> <pre><code>huggingface-cli login\n</code></pre> <p>To pre-download the checkpoint manually:</p> <pre><code>huggingface-cli download facebook/OMol25 checkpoints/esen_sm_conserving_all.pt --local-dir .\n</code></pre>"},{"location":"concepts/","title":"Key Concepts","text":"<p>This section explains the fundamental concepts behind NEB Dynamics.</p>"},{"location":"concepts/#nodes-and-chains","title":"Nodes and Chains","text":""},{"location":"concepts/#nodes","title":"Nodes","text":"<p>A Node represents a single molecular structure (geometry) along a reaction path. The main node types are:</p> <ul> <li><code>StructureNode</code>: Represents a molecular structure with geometry, symbols, charge, and multiplicity. Stores cached energy and gradient data.</li> <li><code>XYNode</code>: A simplified node for 2D coordinates (useful for model systems).</li> </ul> <p>Nodes are containers for molecular structures that also hold computational results: <pre><code>from neb_dynamics import StructureNode\nfrom qcio import Structure\n\n# Create a node from a structure\nstructure = Structure.from_smiles(\"C=O\")\nnode = StructureNode(structure=structure)\n\n# Update coordinates\nnew_coords = node.coords + 0.1  # Slight displacement\nnew_node = node.update_coords(new_coords)\n</code></pre></p>"},{"location":"concepts/#chains","title":"Chains","text":"<p>A Chain is a collection of Nodes representing a reaction pathway. It contains: - A list of Node objects (images along the path) - Chain parameters (spring constants, interpolation settings)</p> <pre><code>from neb_dynamics import Chain, ChainInputs\nfrom neb_dynamics.nodes import StructureNode\nfrom qcio import Structure\n\n# Create a chain from nodes\nnodes = [StructureNode(structure=Structure.from_smiles(s)) for s in [\"C=O\", \"C[O]\"]]\nchain = Chain(nodes=nodes, parameters=ChainInputs())\n\n# Access chain properties\nprint(chain.energies)       # Energy of each node\nprint(chain.gradients)      # Gradient of each node\nprint(chain.coordinates)    # Atomic coordinates\nprint(chain.path_length)    # Integrated path length\n</code></pre>"},{"location":"concepts/#the-nudged-elastic-band-method","title":"The Nudged Elastic Band Method","text":""},{"location":"concepts/#how-neb-works","title":"How NEB Works","text":"<p>NEB finds the minimum energy path by: 1. Creating a chain of images between reactant and product 2. Optimizing images simultaneously using spring forces (to keep them spaced) and perpendicular forces (to push toward the MEP)</p>"},{"location":"concepts/#key-equations","title":"Key Equations","text":"<p>The total force on each image consists of two components:</p> <p>Spring Force (parallel to path): <pre><code>F_spring = k * (|R_i+1 - R_i| - d) * t\n</code></pre> where <code>t</code> is the tangent direction.</p> <p>Perpendicular Gradient (perpendicular to path): <pre><code>F_perp = -\u2207E + (\u2207E \u00b7 t) * t\n</code></pre></p> <p>The \"nudging\" removes the component of the spring force perpendicular to the path, ensuring images don't climb barriers.</p>"},{"location":"concepts/#climbing-image-neb","title":"Climbing Image NEB","text":"<p>Enable with <code>NEBInputs(climb=True)</code> - the image with highest energy climbs to the saddle point.</p> <pre><code>nbi = NEBInputs(climb=True)\n</code></pre>"},{"location":"concepts/#geodesic-interpolation","title":"Geodesic Interpolation","text":"<p>Geodesic interpolation provides better initial path guesses than linear interpolation, especially for reactions involving bond breaking/forming.</p>"},{"location":"concepts/#how-it-works","title":"How It Works","text":"<ol> <li>Calculate pairwise distances between all atoms</li> <li>Find a path that minimizes the sum of geodesic distances</li> <li>Generate images along this path</li> </ol> <pre><code>import neb_dynamics.chainhelpers as ch\nfrom neb_dynamics.inputs import ChainInputs, GIInputs\n\n# Geodesic interpolation\ngi_inputs = GIInputs(nimages=15, friction=0.001, nudge=0.1)\ninitial_chain = ch.run_geodesic([start_node, end_node],\n                                 chain_inputs=ChainInputs(),\n                                 nimages=15)\n</code></pre>"},{"location":"concepts/#parameters","title":"Parameters","text":"<ul> <li><code>nimages</code>: Number of images in the chain</li> <li><code>friction</code>: Controls penalty for large pairwise distances (lower = more flexible)</li> <li><code>nudge</code>: Nudge parameter for path optimization</li> </ul>"},{"location":"concepts/#multi-step-mep-msmep","title":"Multi-Step MEP (MSMEP)","text":"<p>MSMEP automatically handles complex reactions with multiple elementary steps:</p> <ol> <li>Run NEB on initial path</li> <li>Check if the path represents a single elementary step</li> <li>If not, split the path at intermediate minima</li> <li>Recursively minimize each segment</li> <li>Build a tree of all pathways found</li> </ol> <pre><code>from neb_dynamics import MSMEP, RunInputs\n\n# Run recursive minimization\ninputs = RunInputs(path_min_method='NEB')\nm = MSMEP(inputs=inputs)\n\n# This will automatically split if needed\nhistory = m.run_recursive_minimize(initial_chain)\n</code></pre>"},{"location":"concepts/#convergence-criteria","title":"Convergence Criteria","text":"<p>NEB Dynamics uses multiple convergence criteria:</p> Parameter Description Default <code>en_thre</code> Energy difference threshold (Ha) 1e-4 <code>rms_grad_thre</code> RMS perpendicular gradient threshold 0.02 Ha/Bohr <code>max_rms_grad_thre</code> Maximum RMS gradient threshold 0.05 Ha/Bohr <code>ts_grad_thre</code> Transition state gradient threshold 0.05 Ha/Bohr <code>ts_spring_thre</code> TS spring force threshold 0.02 Ha/Bohr <code>barrier_thre</code> Barrier height change threshold (kcal/mol) 0.1 <code>max_steps</code> Maximum optimization steps 500"},{"location":"concepts/#visualization","title":"Visualization","text":"<p>NEB Dynamics provides several visualization tools:</p> <pre><code>import neb_dynamics.chainhelpers as ch\n\n# Plot energy profile\nchain.plot_chain()\n\n# Plot optimization history\nn.plot_opt_history(1)\n\n# Plot convergence metrics\nn.plot_convergence_metrics()\n\n# Visualize chain in 3D\nch.visualize_chain(chain)\n</code></pre>"},{"location":"engines/","title":"Electronic Structure Engines","text":"<p>NEB Dynamics supports multiple electronic structure engines through a common interface. Engines handle energy and gradient calculations for molecular structures.</p>"},{"location":"engines/#available-engines","title":"Available Engines","text":"Engine Description Use Case <code>QCOPEngine</code> Uses QCOP to interface with quantum chemistry codes Production calculations with ChemCloud, XTB, ORCA, etc. <code>ASEEngine</code> Interfaces with ASE calculators ML potentials, custom methods <code>LEPSEngine</code> Simple LEPS potential Testing, model systems <code>ThreeWellEngine</code> Three-well potential Testing, model systems"},{"location":"engines/#chemcloud-setup","title":"ChemCloud Setup","text":"<p>ChemCloud is the recommended way to run electronic structure calculations. You'll need:</p> <ol> <li>Sign up at https://chemcloud.mtzlab.com/signup</li> <li>Configure authentication (choose one option):</li> </ol> <pre><code># Option 1: Run setup_profile() - writes credentials to ~/.chemcloud/credentials\npython -c \"from chemcloud import setup_profile; setup_profile()\"\n\n# Option 2: Use environment variables (for memory-only auth)\nexport CHEMCLOUD_USERNAME=your_email@chemcloud.com\nexport CHEMCLOUD_PASSWORD=your_password\n\n# Option 3: Custom server (if using a different domain)\nexport CHEMCLOUD_DOMAIN=\"https://your-server-url.com\"\n</code></pre>"},{"location":"engines/#qcopengine","title":"QCOPEngine","text":"<p>The QCOPEngine interfaces with various quantum chemistry programs through QCOP.</p>"},{"location":"engines/#basic-usage","title":"Basic Usage","text":"<pre><code>from neb_dynamics.engines.qcop import QCOPEngine\n\n# Using ChemCloud (recommended)\neng = QCOPEngine(compute_program=\"chemcloud\")\n\n# Default: uses XTB\neng = QCOPEngine()\n\n# Or specify program arguments\nfrom qcio import ProgramArgs\n\nargs = ProgramArgs(\n    model={\"method\": \"GFN2xTB\", \"basis\": \"GFN2xTB\"},\n    keywords={\"threads\": 4}\n)\neng = QCOPEngine(program_args=args, program=\"xtb\")\n</code></pre>"},{"location":"engines/#features","title":"Features","text":"<ul> <li>Geometry Optimization: <code>eng.compute_geometry_optimization(node)</code></li> <li>Energy Calculation: <code>eng.compute_energies(chain)</code></li> <li>Gradient Calculation: <code>eng.compute_gradients(chain)</code></li> <li>Supports external programs: XTB, ORCA, TeraChem, Psi4, etc.</li> </ul>"},{"location":"engines/#supported-programs","title":"Supported Programs","text":"<pre><code># ChemCloud (recommended)\neng = QCOPEngine(compute_program=\"chemcloud\")\n\n# XTB (default, requires local installation)\neng = QCOPEngine(program=\"xtb\")\n\n# ORCA\neng = QCOPEngine(program=\"orca\")\n\n# TeraChem\neng = QCOPEngine(program=\"terachem\")\n</code></pre>"},{"location":"engines/#aseengine","title":"ASEEngine","text":"<p>The ASEEngine interfaces with ASE (Atomic Simulation Environment) calculators, enabling use of machine learning potentials and other methods.</p>"},{"location":"engines/#basic-usage_1","title":"Basic Usage","text":"<pre><code>from neb_dynamics.engines.ase import ASEEngine\nfrom mace.calculators import MACECalculator\n\n# Load MACE potential\ncalc = MACECalculator(model=\"mace-medium\", device=\"cuda\")\neng = ASEEngine(calculator=calc)\n\n# Now run NEB as usual\nn = NEB(initial_chain=initial_chain, parameters=nbi, optimizer=opt, engine=eng)\n</code></pre>"},{"location":"engines/#ase-optimizers","title":"ASE Optimizers","text":"<pre><code>from neb_dynamics.engines.ase import ASEEngine\n\neng = ASEEngine(\n    calculator=calc,\n    geometry_optimizer=\"LBFGSLineSearch\"  # Default\n)\n</code></pre> <p>Available optimizers: <code>LBFGS</code>, <code>BFGS</code>, <code>FIRE</code>, <code>LBFGSLineSearch</code>, <code>MDMin</code></p>"},{"location":"engines/#engine-interface","title":"Engine Interface","text":"<p>All engines implement the following interface:</p> <pre><code>class Engine:\n    def compute_gradients(self, chain: Union[Chain, List]) -&gt; NDArray:\n        \"\"\"Compute gradients for each node in the chain\"\"\"\n        ...\n\n    def compute_energies(self, chain: Union[Chain, List]) -&gt; NDArray:\n        \"\"\"Compute energies for each node in the chain\"\"\"\n        ...\n\n    def compute_geometry_optimization(self, node: Node) -&gt; List[Node]:\n        \"\"\"Optimize a single node geometry\"\"\"\n        ...\n</code></pre>"},{"location":"engines/#using-with-chains","title":"Using with Chains","text":"<p>Engines work with Chain objects to compute properties:</p> <pre><code># Create engine\neng = QCOPEngine(compute_program=\"chemcloud\")\n\n# Compute energies (also computes gradients internally)\nenergies = eng.compute_energies(chain)\n\n# Compute gradients explicitly\ngradients = eng.compute_gradients(chain)\n\n# Optimize a single structure\noptimized_node = eng.compute_geometry_optimization(start_node)\ntrajectory = eng.compute_geometry_optimization(start_node)  # Returns full trajectory\nfinal_structure = trajectory[-1]\n</code></pre>"},{"location":"engines/#choosing-an-engine","title":"Choosing an Engine","text":""},{"location":"engines/#use-qcopengine-with-chemcloud-when","title":"Use QCOPEngine with ChemCloud when:","text":"<ul> <li>Running production calculations</li> <li>Don't want to install local quantum chemistry software</li> <li>Need reliable cloud computing</li> </ul>"},{"location":"engines/#use-aseengine-when","title":"Use ASEEngine when:","text":"<ul> <li>Using machine learning potentials (MACE, NequIP, etc.)</li> <li>Need custom ASE calculators</li> <li>Have GPU access for ML potentials</li> </ul>"},{"location":"inputs/","title":"Input Parameters","text":"<p>NEB Dynamics uses several input classes to configure calculations. This guide covers all available options.</p>"},{"location":"inputs/#nebinputs","title":"NEBInputs","text":"<p>Controls Nudged Elastic Band optimization parameters.</p> <pre><code>from neb_dynamics.inputs import NEBInputs\n\nnbi = NEBInputs(\n    # Convergence thresholds\n    tol=1e-4,                    # Overall tolerance (Hartrees)\n    en_thre=1e-4,                # Energy difference threshold\n    rms_grad_thre=0.02,          # RMS perpendicular gradient (Ha/Bohr)\n    max_rms_grad_thre=0.05,      # Maximum RMS gradient (Ha/Bohr)\n    ts_grad_thre=0.05,           # Transition state gradient threshold\n    ts_spring_thre=0.02,         # TS spring force threshold\n    barrier_thre=0.1,            # Barrier height change (kcal/mol)\n\n    # NEB options\n    climb=False,                 # Enable climbing image NEB\n    use_geodesic_tangent=False,  # Use geodesic tangents\n\n    # Early stopping\n    early_stop_force_thre=0.0,   # Early stop check threshold\n\n    # Step control\n    negative_steps_thre=10,      # Steps before halving step size\n    max_steps=500,               # Maximum optimization steps\n\n    # Other options\n    skip_identical_graphs=True,   # Skip if endpoints have same graph\n    do_elem_step_checks=True,    # Check for elementary steps\n    v=True,                      # Verbose output\n)\n</code></pre>"},{"location":"inputs/#parameter-reference","title":"Parameter Reference","text":"Parameter Type Default Description <code>climb</code> bool False Enable climbing image NEB to find exact saddle point <code>en_thre</code> float 1e-4 Energy difference threshold (Hartrees) <code>rms_grad_thre</code> float 0.02 RMS perpendicular gradient threshold (Ha/Bohr) <code>max_rms_grad_thre</code> float 0.05 Maximum RMS gradient threshold (Ha/Bohr) <code>ts_grad_thre</code> float 0.05 Transition state gradient infinity norm (Ha/Bohr) <code>ts_spring_thre</code> float 0.02 TS spring force infinity norm (Ha/Bohr) <code>barrier_thre</code> float 0.1 Barrier height change threshold (kcal/mol) <code>early_stop_force_thre</code> float 0.0 Early stop check (0 = disabled) <code>negative_steps_thre</code> int 10 Steps with poor gradient correlation before halving step size <code>max_steps</code> int 500 Maximum optimization steps <code>skip_identical_graphs</code> bool True Skip minimization if endpoints have identical molecular graphs <code>do_elem_step_checks</code> bool False Check if path is elementary step during optimization <code>use_geodesic_tangent</code> bool False Use geodesic-based tangents instead of standard <code>v</code> bool True Verbose output"},{"location":"inputs/#chaininputs","title":"ChainInputs","text":"<p>Controls the chain of images and path interpolation.</p> <pre><code>from neb_dynamics.inputs import ChainInputs\n\nci = ChainInputs(\n    # Spring constants\n    k=0.1,           # Maximum spring constant\n    delta_k=0.09,    # Energy-weighted spring constant parameter\n\n    # Parallel computation\n    do_parallel=True, # Compute gradients in parallel\n\n    # Interpolation\n    use_geodesic_interpolation=True,  # Use geodesic interpolation\n    friction_optimal_gi=True,         # Optimize friction parameter\n\n    # Node freezing\n    node_freezing=True,    # Enable node freezing\n    node_rms_thre=5.0,     # RMS threshold for freezing (Bohr)\n    node_ene_thre=5.0,     # Energy threshold for freezing (kcal/mol)\n\n    # Frozen atoms\n    frozen_atom_indices=\"\",  # Space-separated indices of frozen atoms\n)\n</code></pre>"},{"location":"inputs/#parameter-reference_1","title":"Parameter Reference","text":"Parameter Type Default Description <code>k</code> float 0.1 Maximum spring constant for NEB <code>delta_k</code> float 0.09 Parameter for energy-weighted spring constants <code>do_parallel</code> bool True Compute gradients in parallel <code>use_geodesic_interpolation</code> bool True Use geodesic interpolation for initial path <code>friction_optimal_gi</code> bool True Optimize friction parameter for GI <code>node_freezing</code> bool True Freeze nodes that have converged <code>node_rms_thre</code> float 5.0 RMS coordinate change threshold for freezing (Bohr) <code>node_ene_thre</code> float 5.0 Energy change threshold for freezing (kcal/mol) <code>frozen_atom_indices</code> str \"\" Indices of atoms to freeze during optimization"},{"location":"inputs/#energy-weighted-spring-constants","title":"Energy-Weighted Spring Constants","text":"<p>The energy-weighted spring constant is calculated as: <pre><code>k_i = k * exp(-delta_k * (E_i - E_min) / (E_max - E_min))\n</code></pre></p> <p>This keeps images more tightly spaced near the barrier where energies change rapidly.</p>"},{"location":"inputs/#giinputs","title":"GIInputs","text":"<p>Controls geodesic interpolation for generating initial path guesses.</p> <pre><code>from neb_dynamics.inputs import GIInputs\n\ngi = GIInputs(\n    nimages=10,           # Number of images\n    friction=0.001,       # Friction parameter\n    nudge=0.1,            # Nudge parameter\n    align=True,           # Align structures before interpolation\n    extra_kwds={},        # Additional keywords\n)\n</code></pre>"},{"location":"inputs/#parameter-reference_2","title":"Parameter Reference","text":"Parameter Type Default Description <code>nimages</code> int 10 Number of images in the chain <code>friction</code> float 0.001 Friction parameter (controls path smoothness) <code>nudge</code> float 0.1 Nudge parameter for path optimization <code>align</code> bool True Align structures using RMSD before interpolation <code>extra_kwds</code> dict {} Additional geodesic interpolation options"},{"location":"inputs/#tips-for-geodesic-interpolation","title":"Tips for Geodesic Interpolation","text":"<ul> <li>Higher <code>nudge</code> values produce shorter paths but may be less smooth</li> <li>Lower <code>friction</code> values allow more flexibility in atomic movements</li> <li>Run multiple interpolations with different parameters and select the shortest path</li> </ul>"},{"location":"inputs/#runinputs","title":"RunInputs","text":"<p>Complete input class for running MSMEP calculations.</p> <pre><code>from neb_dynamics.inputs import RunInputs\nfrom qcio import ProgramArgs\n\nri = RunInputs(\n    # Engine settings\n    engine_name=\"qcop\",      # \"qcop\", \"ase\", or \"chemcloud\"\n    program=\"xtb\",           # Electronic structure program\n\n    # Path minimization\n    path_min_method=\"NEB\",   # \"NEB\", \"FNEB\", or \"MLPGI\"\n\n    # Program arguments\n    program_kwds=ProgramArgs(\n        model={\"method\": \"GFN2xTB\", \"basis\": \"GFN2xTB\"},\n        keywords={}\n    ),\n\n    # Custom inputs\n    path_min_inputs=NEBInputs().__dict__,\n    chain_inputs=ChainInputs().__dict__,\n    gi_inputs=GIInputs().__dict__,\n\n    # Optimizer\n    optimizer_kwds={\"timestep\": 0.5},\n)\n</code></pre>"},{"location":"inputs/#parameter-reference_3","title":"Parameter Reference","text":"Parameter Type Default Description <code>engine_name</code> str \"qcop\" Engine to use: \"qcop\", \"ase\", or \"chemcloud\" <code>program</code> str \"xtb\" Electronic structure program <code>path_min_method</code> str \"NEB\" Path minimization method: \"NEB\", \"FNEB\", \"MLPGI\" <code>program_kwds</code> ProgramArgs None Program-specific arguments <code>path_min_inputs</code> dict {} NEBInputs as dictionary <code>chain_inputs</code> dict {} ChainInputs as dictionary <code>gi_inputs</code> dict {} GIInputs as dictionary <code>optimizer_kwds</code> dict {\"timestep\": 0.5} Optimizer keyword arguments"},{"location":"inputs/#loadingsaving-inputs","title":"Loading/Saving Inputs","text":"<pre><code># Save inputs to TOML file\nri.save(\"my_inputs.toml\")\n\n# Load inputs from TOML file\nri = RunInputs.open(\"my_inputs.toml\")\n</code></pre>"},{"location":"inputs/#networkinputs","title":"NetworkInputs","text":"<p>Settings for building reaction networks.</p> <pre><code>from neb_dynamics.inputs import NetworkInputs\n\nni = NetworkInputs(\n    # Conformer generation\n    n_max_conformers=10,      # Maximum conformers per endpoint\n    subsample_confs=True,      # Subsample conformers\n    conf_rmsd_cutoff=0.5,     # RMSD cutoff for new conformer (Angstroms)\n\n    # Network settings\n    network_nodes_are_conformers=False,  # Each conformer is a node\n    maximum_barrier_height=1000,         # Max barrier (kcal/mol)\n    tolerate_kinks=True,                  # Include paths with kinks\n\n    # Computing\n    use_slurm=False,           # Submit to SLURM queue\n\n    # CREST settings\n    CREST_temp=298.15,         # Temperature (K)\n    CREST_ewin=6.0,            # Energy window (kcal/mol)\n)\n</code></pre>"},{"location":"inputs/#path-minimization-methods","title":"Path Minimization Methods","text":""},{"location":"inputs/#standard-neb","title":"Standard NEB","text":"<p>The standard Nudged Elastic Band method with spring forces and perpendicular gradients.</p> <pre><code>nbi = NEBInputs()\n</code></pre>"},{"location":"inputs/#freezing-neb-fneb","title":"Freezing NEB (FNEB)","text":"<p>Grow the chain dynamically, freezing images once they converge.</p> <pre><code>from neb_dynamics.inputs import RunInputs\n\nri = RunInputs(\n    path_min_method=\"FNEB\",\n    path_min_inputs={\n        \"max_min_iter\": 100,\n        \"max_grow_iter\": 20,\n        \"grad_tol\": 0.05,\n        \"barrier_thre\": 5,\n    }\n)\n</code></pre>"},{"location":"inputs/#mlp-geodesic-mlpgi","title":"MLP Geodesic (MLPGI)","text":"<p>Using machine learning potentials with geodesic interpolation.</p> <pre><code>ri = RunInputs(\n    path_min_method=\"MLPGI\",\n    path_min_inputs={\n        # MLP backend config\n        \"backend\": \"fairchem\",\n        \"device\": \"cpu\",          # \"cpu\" or \"cuda\"\n        \"dtype\": \"float32\",       # \"float32\" or \"float64\"\n\n        # Checkpoint resolution\n        \"model_path\": \"esen_sm_conserving_all.pt\",\n        \"model_repo\": \"facebook/OMol25\",\n        \"auto_download_model\": True,\n        # Optional:\n        # \"model_cache_dir\": \"/path/to/cache\",\n        # \"hf_token\": \"hf_xxx\",\n    },\n)\n</code></pre>"},{"location":"inputs/#mlpgi-checkpoint-setup","title":"MLPGI Checkpoint Setup","text":"<p><code>MLPGI</code> requires a local fairchem checkpoint file. You can provide one directly or enable automatic download from Hugging Face.</p> <ol> <li>Manual checkpoint path:</li> </ol> <pre><code>ri = RunInputs(\n    path_min_method=\"MLPGI\",\n    path_min_inputs={\n        \"backend\": \"fairchem\",\n        \"model_path\": \"/absolute/path/to/esen_sm_conserving_all.pt\",\n        \"auto_download_model\": False,\n    },\n)\n</code></pre> <ol> <li>Auto-download from Hugging Face (<code>facebook/OMol25</code>):</li> </ol> <pre><code>ri = RunInputs(\n    path_min_method=\"MLPGI\",\n    path_min_inputs={\n        \"backend\": \"fairchem\",\n        \"model_path\": \"esen_sm_conserving_all.pt\",\n        \"model_repo\": \"facebook/OMol25\",\n        \"auto_download_model\": True,\n    },\n)\n</code></pre> <p>If the repo is gated/private, authenticate first:</p> <pre><code>huggingface-cli login\n</code></pre> <p>You can also set <code>HF_TOKEN</code> in your environment instead of interactive login.</p> <p>Manual download example (stores in local directory):</p> <pre><code>huggingface-cli download facebook/OMol25 checkpoints/esen_sm_conserving_all.pt --local-dir .\n</code></pre>"},{"location":"inputs/#mlpgi-runtime-messaging","title":"MLPGI Runtime Messaging","text":"<p>MLPGI now reports progress through the same Rich/status pipeline used by NEB: spinner updates via <code>update_status(...)</code> in non-verbose mode, and plain prints in verbose mode. This keeps MLPGI output consistent with autosplitting runs.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial walks through using NEB Dynamics for finding reaction pathways.</p>"},{"location":"tutorial/#prerequisites","title":"Prerequisites","text":"<p>Install NEB Dynamics and dependencies:</p> <pre><code>pip install \"git+https://github.com/mtzgroup/neb-dynamics.git\"\n</code></pre> <p>Note: These tutorials use ChemCloud for electronic structure calculations. You'll need: 1. Sign up at https://chemcloud.mtzlab.com/signup 2. Configure authentication:</p> <pre><code># Option 1: Run setup_profile() - writes credentials to ~/.chemcloud/credentials\npython -c \"from chemcloud import setup_profile; setup_profile()\"\n\n# Option 2: Use environment variables (for memory-only auth)\nexport CHEMCLOUD_USERNAME=your_email@chemcloud.com\nexport CHEMCLOUD_PASSWORD=your_password\n</code></pre>"},{"location":"tutorial/#tutorial-1-simple-neb-calculation","title":"Tutorial 1: Simple NEB Calculation","text":"<p>Calculate an SN2 reaction: bromide substitution by hydroxide.</p>"},{"location":"tutorial/#step-1-create-initial-and-final-structures","title":"Step 1: Create Initial and Final Structures","text":"<pre><code>from qcio import Structure\nfrom neb_dynamics import StructureNode\n\n# Define structures using embedded XYZ data\nstart_xyz = \"\"\"17\nFrame 0\n C          0.885440409184        2.102076768875        0.627821743488\n C          0.841612815857        1.115651130676       -0.247040778399\n C         -0.420807182789        0.556873917580       -0.838685691357\n O         -0.430870711803        0.798001468182       -2.239025592804\n C         -0.522329509258       -0.964021146297       -0.644988238811\n C         -0.715307652950       -1.349323630333        0.785972416401\n C          0.097422197461       -2.135773420334        1.466876506805\n H         -0.267592728138        1.735007524490       -2.391090631485\n H         -1.386946558952       -1.296320080757       -1.227010726929\n H          0.993258416653       -2.552916049957        1.031124353409\n H         -0.008914750069        2.554719924927        1.029638171196\n H          1.820721507072        2.502734899521        0.982666194439\n H          1.748645901680        0.692936420441       -0.660514891148\n H         -1.296261906624        1.040292620659       -0.372635990381\n H          0.376222431660       -1.434682250023       -1.046772599220\n H         -1.611668467522       -0.956238925457        1.253052473068\n H         -0.102624341846       -2.409019231796        2.490613460541\n\"\"\"\n\nend_xyz = \"\"\"17\nFrame 29\n C          0.576232671738        0.921668708324        0.825146675110\n C          0.811691701412        1.315650582314       -0.631796598434\n C         -0.290672153234        0.930290937424       -1.571661710739\n O         -0.139186233282        0.584553778172       -2.709024667740\n C         -1.166546344757       -1.861497998238       -0.220005810261\n C         -0.774998486042       -1.183089017868        0.841198801994\n C          0.589584112167       -0.601971745491        1.032947182655\n H          0.880913138390        2.407624959946       -0.707833826542\n H         -2.171884059906       -2.235154390335       -0.311172336340\n H          1.294490098953       -1.047748923302        0.330671131611\n H         -0.374946832657        1.333065629005        1.164748311043\n H          1.358177542686        1.381788730621        1.429385662079\n H          1.752718806267        0.898995816708       -0.990877032280\n H         -1.302031993866        1.039528012276       -1.137167930603\n H         -0.504405736923       -2.070925474167       -1.043461441994\n H         -1.469262003899       -0.993297398090        1.650624632835\n H          0.930125653744       -0.819482147694        2.048279047012\n\"\"\"\n\n# Load structures from XYZ strings\nstart = Structure.from_xyz(start_xyz)\nend = Structure.from_xyz(end_xyz)\n\n# Create nodes\nstart_node = StructureNode(structure=start)\nend_node = StructureNode(structure=end)\n</code></pre>"},{"location":"tutorial/#step-2-optimize-endpoints","title":"Step 2: Optimize Endpoints","text":"<pre><code>from neb_dynamics.engines.qcop import QCOPEngine\n\n# Using ChemCloud for electronic structure\neng = QCOPEngine(compute_program=\"chemcloud\")\n\n# Optimize geometries\nstart_opt = eng.compute_geometry_optimization(start_node)\nend_opt = eng.compute_geometry_optimization(end_node)\n\n# Get final optimized structures\nstart_node = start_opt[-1]\nend_node = end_opt[-1]\n</code></pre>"},{"location":"tutorial/#step-3-create-initial-chain-with-geodesic-interpolation","title":"Step 3: Create Initial Chain with Geodesic Interpolation","text":"<pre><code>import neb_dynamics.chainhelpers as ch\nfrom neb_dynamics.inputs import ChainInputs\nfrom neb_dynamics import Chain\n\n# Set up chain inputs\ncni = ChainInputs(k=0.1, delta_k=0.09)\n\n# Create a Chain object first\nchain = Chain.model_validate({\n    'nodes': [start_node, end_node],\n    'parameters': cni\n})\n\n# Generate initial path using geodesic interpolation\ninitial_chain = ch.run_geodesic(chain, nimages=15)\n</code></pre>"},{"location":"tutorial/#step-4-run-neb-optimization","title":"Step 4: Run NEB Optimization","text":"<pre><code>from neb_dynamics.neb import NEB\nfrom neb_dynamics.inputs import NEBInputs\nfrom neb_dynamics.optimizers.vpo import VelocityProjectedOptimizer\nfrom neb_dynamics.optimizers.cg import ConjugateGradient\n\n# Set up NEB parameters\nnbi = NEBInputs(v=True)\n\n# Choose optimizer\n# Velocity Projected Optimizer (recommended)\nopt = VelocityProjectedOptimizer(timestep=0.5)\n\n# Or Conjugate Gradient\n# opt = ConjugateGradient(timestep=0.5)\n\n# Create NEB object\nn = NEB(\n    initial_chain=initial_chain,\n    parameters=nbi,\n    optimizer=opt,\n    engine=eng\n)\n\n# Run optimization\nelem_step_results = n.optimize_chain()\n</code></pre>"},{"location":"tutorial/#step-5-visualize-results","title":"Step 5: Visualize Results","text":"<pre><code># Plot optimization history\nn.plot_opt_history(1)\n\n# Plot energy profile\nn.optimized.plot_chain()\n\n# Visualize chain in 3D\nch.visualize_chain(n.optimized)\n</code></pre>"},{"location":"tutorial/#tutorial-2-using-climbing-image-neb","title":"Tutorial 2: Using Climbing Image NEB","text":"<p>Climbing image NEB finds the exact saddle point:</p> <pre><code># Enable climbing image\nnbi = NEBInputs(climb=True)\n\nn = NEB(\n    initial_chain=initial_chain,\n    parameters=nbi,\n    optimizer=VelocityProjectedOptimizer(timestep=0.5),\n    engine=eng\n)\n\nresults = n.optimize_chain()\n</code></pre>"},{"location":"tutorial/#tutorial-3-multi-step-mep-msmep","title":"Tutorial 3: Multi-Step MEP (MSMEP)","text":"<p>For complex reactions with multiple elementary steps, use MSMEP:</p> <pre><code>from qcio import Structure\nfrom neb_dynamics import MSMEP, RunInputs, StructureNode, ChainInputs\nfrom neb_dynamics.engines.qcop import QCOPEngine\nimport neb_dynamics.chainhelpers as ch\n\n# Set up engine with ChemCloud\neng = QCOPEngine(compute_program=\"chemcloud\")\n\n# Set up inputs - use engine_name=\"chemcloud\" to run on ChemCloud\nri = RunInputs(\n    engine_name=\"chemcloud\",\n    program=\"xtb\",  # Program to use on ChemCloud\n    path_min_method=\"NEB\",\n)\n\nm = MSMEP(inputs=ri)\n\n# Create structures using embedded XYZ data\nstart_xyz = \"\"\"17\nFrame 0\n C          0.885440409184        2.102076768875        0.627821743488\n C          0.841612815857        1.115651130676       -0.247040778399\n C         -0.420807182789        0.556873917580       -0.838685691357\n O         -0.430870711803        0.798001468182       -2.239025592804\n C         -0.522329509258       -0.964021146297       -0.644988238811\n C         -0.715307652950       -1.349323630333        0.785972416401\n C          0.097422197461       -2.135773420334        1.466876506805\n H         -0.267592728138        1.735007524490       -2.391090631485\n H         -1.386946558952       -1.296320080757       -1.227010726929\n H          0.993258416653       -2.552916049957        1.031124353409\n H         -0.008914750069        2.554719924927        1.029638171196\n H          1.820721507072        2.502734899521        0.982666194439\n H          1.748645901680        0.692936420441       -0.660514891148\n H         -1.296261906624        1.040292620659       -0.372635990381\n H          0.376222431660       -1.434682250023       -1.046772599220\n H         -1.611668467522       -0.956238925457        1.253052473068\n H         -0.102624341846       -2.409019231796        2.490613460541\n\"\"\"\n\nend_xyz = \"\"\"17\nFrame 29\n C          0.576232671738        0.921668708324        0.825146675110\n C          0.811691701412        1.315650582314       -0.631796598434\n C         -0.290672153234        0.930290937424       -1.571661710739\n O         -0.139186233282        0.584553778172       -2.709024667740\n C         -1.166546344757       -1.861497998238       -0.220005810261\n C         -0.774998486042       -1.183089017868        0.841198801994\n C          0.589584112167       -0.601971745491        1.032947182655\n H          0.880913138390        2.407624959946       -0.707833826542\n H         -2.171884059906       -2.235154390335       -0.311172336340\n H          1.294490098953       -1.047748923302        0.330671131611\n H         -0.374946832657        1.333065629005        1.164748311043\n H          1.358177542686        1.381788730621        1.429385662079\n H          1.752718806267        0.898995816708       -0.990877032280\n H         -1.302031993866        1.039528012276       -1.137167930603\n H         -0.504405736923       -2.070925474167       -1.043461441994\n H         -1.469262003899       -0.993297398090        1.650624632835\n H          0.930125653744       -0.819482147694        2.048279047012\n\"\"\"\n\n# Load structures from XYZ strings\nstart = Structure.from_xyz(start_xyz)\nend = Structure.from_xyz(end_xyz)\n\nstart_node = StructureNode(structure=start)\nend_node = StructureNode(structure=end)\n\n# Optimize endpoints\nstart_opt = eng.compute_geometry_optimization(start_node)\nstart_node = start_opt[-1]\n\nend_opt = eng.compute_geometry_optimization(end_node)\nend_node = end_opt[-1]\n\n# Create initial chain using Chain.model_validate()\nchain = Chain.model_validate({\n    'nodes': [start_node, end_node],\n    'parameters': ChainInputs(k=0.1, delta_k=0.09)\n})\ninitial_chain = ch.run_geodesic(chain, nimages=20)\n\n# Run recursive minimization\n# This will automatically split the path if needed\nhistory = m.run_recursive_minimize(initial_chain)\n\n# Visualize final path\nch.visualize_chain(history.data.optimized)\n</code></pre>"},{"location":"tutorial/#tutorial-4-custom-convergence-criteria","title":"Tutorial 4: Custom Convergence Criteria","text":"<p>Adjust convergence thresholds for your needs:</p> <pre><code># Tight convergence for high-accuracy calculations\nnbi_tight = NEBInputs(\n    en_thre=1e-5,           # Tighter energy threshold\n    rms_grad_thre=0.002,     # Tighter gradient threshold\n    max_steps=1000,          # More steps allowed\n)\n\n# Loose convergence for quick screening\nnbi_loose = NEBInputs(\n    en_thre=1e-3,\n    rms_grad_thre=0.1,\n    max_steps=100,\n)\n</code></pre>"},{"location":"tutorial/#tutorial-6-loading-and-saving-calculations","title":"Tutorial 6: Loading and Saving Calculations","text":"<p>Save intermediate and final results:</p> <pre><code># Save chain to disk\nn.optimized.write_to_disk(\"final_chain.xyz\", write_qcio=True)\n\n# Save complete NEB history\nimport os\nos.makedirs(\"neb_history\", exist_ok=True)\nfor i, chain in enumerate(n.chain_trajectory):\n    chain.write_to_disk(f\"neb_history/traj_{i}.xyz\")\n\n# Load chain from xyz\nfrom neb_dynamics import Chain, ChainInputs\nloaded_chain = Chain.from_xyz(\"final_chain.xyz\", parameters=ChainInputs())\n</code></pre>"},{"location":"tutorial/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"tutorial/#problem-chain-doesnt-converge","title":"Problem: Chain doesn't converge","text":"<p>Solutions: - Increase <code>max_steps</code> - Reduce timestep in optimizer - Check that endpoints are properly optimized - Try different <code>k</code> and <code>delta_k</code> values in ChainInputs</p>"},{"location":"tutorial/#problem-images-bunch-up-at-endpoints","title":"Problem: Images bunch up at endpoints","text":"<p>Solutions: - Enable node freezing (<code>node_freezing=True</code> in ChainInputs) - Use energy-weighted spring constants (higher <code>delta_k</code>)</p>"},{"location":"tutorial/#problem-path-has-kinks","title":"Problem: Path has \"kinks\"","text":"<p>Solutions: - Increase number of images (<code>nimages</code>) - Use geodesic interpolation instead of linear - Enable climbing image NEB</p>"},{"location":"tutorial/#problem-electronic-structure-errors","title":"Problem: Electronic structure errors","text":"<p>Solutions: - Check that structures are chemically reasonable - Try different electronic structure method - Enable <code>do_elem_step_checks</code> for better diagnostics</p>"},{"location":"tutorial/#example-input-file","title":"Example Input File","text":"<p>Create a TOML input file for batch processing:</p> <pre><code>[RunInputs]\nengine_name = \"qcop\"\nprogram = \"xtb\"\npath_min_method = \"NEB\"\n\n[program_kwds]\n[program_kwds.model]\nmethod = \"GFN2xTB\"\nbasis = \"GFN2xTB\"\n\n[chain_inputs]\nk = 0.1\ndelta_k = 0.09\n\n[gi_inputs]\nnimages = 15\nfriction = 0.001\nnudge = 0.1\n\n[path_min_inputs]\nv = true\nmax_steps = 500\n\n[optimizer_kwds]\ntimestep = 0.5\n</code></pre> <p>Then run with ChemCloud by setting up authentication:</p> <pre><code># Option 1: Run setup_profile() - writes credentials to ~/.chemcloud/credentials\npython -c \"from chemcloud import setup_profile; setup_profile()\"\n\n# Option 2: Use environment variables (for memory-only auth)\nexport CHEMCLOUD_USERNAME=your_email@chemcloud.com\nexport CHEMCLOUD_PASSWORD=your_password\n</code></pre> <p>Load and use:</p> <pre><code>from neb_dynamics.inputs import RunInputs\nfrom neb_dynamics import MSMEP\n\ninputs = RunInputs.open(\"my_input.toml\")\nm = MSMEP(inputs=inputs)\nhistory = m.run_recursive_minimize(initial_chain)\n</code></pre>"}]}