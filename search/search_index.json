{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neb Dynamics","text":""},{"location":"#install","title":"Install","text":"<ol> <li><code>pip install \"git+https://github.com/mtzgroup/neb-dynamics.git\"</code></li> </ol>"},{"location":"#maintainers","title":"Maintainers","text":"<p>If you have any questions, please ask: Jan</p>"},{"location":"#tips","title":"Tips","text":"<ul> <li>If using XTB, setting <code>OMP_NUM_THREADS=1</code> can speed up the process when the individual calculation will not benefit from paralellization.</li> </ul>"},{"location":"elementarystep/","title":"Elementarystep","text":"<p>this whole module needs to be revamped and integrated with the qcio results objects probably.</p>"},{"location":"elementarystep/#neb_dynamics.elementarystep.ConcavityResults","title":"<code>ConcavityResults</code>  <code>dataclass</code>","text":"<p>Stores results on concavity checks (i.e. whether chain has a \"dip\" that could be        a new minimum)</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass ConcavityResults:\n    \"\"\"\n    Stores results on concavity checks (i.e. whether chain has a \"dip\" that could be\\\n        a new minimum)\n    \"\"\"\n\n    is_concave: bool\n    minimization_results: list[Node]\n    number_grad_calls: int\n\n    @property\n    def is_not_concave(self):\n        return not self.is_concave\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.ElemStepResults","title":"<code>ElemStepResults</code>  <code>dataclass</code>","text":"<p>Object to build report on minimization from elementary step checks.</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass ElemStepResults:\n    \"\"\"\n    Object to build report on minimization from elementary step checks.\n    \"\"\"\n\n    is_elem_step: bool\n    is_concave: bool\n    splitting_criterion: str\n    minimization_results: List[Node]\n    number_grad_calls: int\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.IRCResults","title":"<code>IRCResults</code>  <code>dataclass</code>","text":"<p>Stores results on (pseudo)IRC checks</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass IRCResults:\n    \"\"\"Stores results on (pseudo)IRC checks\"\"\"\n\n    found_reactant: Node\n    found_product: Node\n    number_grad_calls: int\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.check_if_elem_step","title":"<code>check_if_elem_step(inp_chain, engine)</code>","text":"<p>Calculates whether an input chain is an elementary step.</p> <p>Parameters:</p> Name Type Description Default <code>inp_chain</code> <code>Chain</code> <p>input chain to check.</p> required <p>Returns:</p> Name Type Description <code>ElemStepResults</code> <code>ElemStepResults</code> <p>object containing report on chain.</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>def check_if_elem_step(inp_chain: Chain, engine: Engine) -&gt; ElemStepResults:\n    \"\"\"Calculates whether an input chain is an elementary step.\n\n    Args:\n        inp_chain (Chain): input chain to check.\n\n    Returns:\n        ElemStepResults: object containing report on chain.\n    \"\"\"\n    n_geom_opt_grad_calls = 0\n    chain = inp_chain.copy()\n    if len(inp_chain) &lt;= 1:\n        return ElemStepResults(\n            is_elem_step=True,\n            is_concave=True,\n            splitting_criterion=None,\n            minimization_results=None,\n            number_grad_calls=0,\n        )\n\n    concavity_results = _chain_is_concave(chain=inp_chain, engine=engine)\n    n_geom_opt_grad_calls += concavity_results.number_grad_calls\n\n    if concavity_results.is_not_concave:\n        return ElemStepResults(\n            is_elem_step=False,\n            is_concave=concavity_results.is_concave,\n            splitting_criterion=\"minima\",\n            minimization_results=concavity_results.minimization_results,\n            number_grad_calls=n_geom_opt_grad_calls,\n        )\n\n    crude_irc_passed, ngc_approx_elem_step = is_approx_elem_step(\n        chain=inp_chain, engine=engine\n    )\n    n_geom_opt_grad_calls += ngc_approx_elem_step\n\n    if crude_irc_passed:\n        return ElemStepResults(\n            is_elem_step=True,\n            is_concave=concavity_results.is_concave,\n            splitting_criterion=None,\n            minimization_results=[inp_chain[0], inp_chain[-1]],\n            number_grad_calls=n_geom_opt_grad_calls,\n        )\n\n    pseu_irc_results = pseudo_irc(chain=inp_chain, engine=engine)\n    n_geom_opt_grad_calls += pseu_irc_results.number_grad_calls\n\n    found_r = is_identical(pseu_irc_results.found_reactant, chain[0],\n                        fragment_rmsd_cutoff=inp_chain.parameters.node_rms_thre,\n                        kcal_mol_cutoff=inp_chain.parameters.node_ene_thre)\n    found_p = is_identical(pseu_irc_results.found_product,  chain[-1],\n                        fragment_rmsd_cutoff=inp_chain.parameters.node_rms_thre,\n                        kcal_mol_cutoff=inp_chain.parameters.node_ene_thre)\n    minimizing_gives_endpoints = found_r and found_p\n\n    elem_step = True if minimizing_gives_endpoints else False\n\n    return ElemStepResults(\n        is_elem_step=elem_step,\n        is_concave=concavity_results.is_concave,\n        splitting_criterion=\"maxima\",\n        minimization_results=[\n            pseu_irc_results.found_reactant,\n            pseu_irc_results.found_product,\n        ],\n        number_grad_calls=n_geom_opt_grad_calls,\n    )\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.is_approx_elem_step","title":"<code>is_approx_elem_step(chain, engine, slope_thresh=0.1)</code>","text":"<p>Will do at most 50 steepest descent steps  on geometries neighboring the transition state guess and check whether they are approaching the chain endpoints. If function returns False, the geoms will be fully optimized.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>chain to check on</p> required <code>slope_thresh</code> <code>float</code> <p>Steepest descent optimization will stop when the slope</p> <code>0.1</code> <p>Returns:</p> Type Description <code>(bool, int)</code> <p>whether chain seems to be an elementary step, number grad calls it took to do this check</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>def is_approx_elem_step(\n    chain: Chain, engine: Engine, slope_thresh=0.1\n) -&gt; Tuple[bool, int]:\n    \"\"\"Will do at most 50 steepest descent steps  on geometries neighboring the transition state guess\n    and check whether they are approaching the chain endpoints. If function returns False, the geoms\n    will be fully optimized.\n\n    Args:\n        chain (Chain): chain to check on\n        slope_thresh (float, optional): Steepest descent optimization will stop when the slope\n        of the distances of the minimized geometry to the target endpoint is &gt;= threshold.\n        Defaults to 0.1.\n\n    Returns:\n        (bool, int): whether chain seems to be an elementary step, number grad calls it took to do this check\n\n    \"\"\"\n    if chain.energies_are_monotonic:\n        return True, 0\n\n    arg_max = np.argmax(chain.energies)\n\n    try:\n        r_passes_opt, r_traj = _converges_to_an_endpoints(\n            chain=chain,\n            engine=engine,\n            node_index=(arg_max - 1),\n            direction=-1,\n            slope_thresh=slope_thresh,\n        )\n        p_passes_opt, p_traj = _converges_to_an_endpoints(\n            chain=chain,\n            engine=engine,\n            node_index=(arg_max + 1),\n            direction=+1,\n            slope_thresh=slope_thresh,\n        )\n    except Exception as e:\n        import traceback\n\n        print(traceback.format_exc())\n        print(\n            f\"Error in geometry optimization: {e}. Pretending this is an elem step.\"\n        )\n        return True, 0\n    nodes_have_graph = chain.nodes[0].has_molecular_graph\n    # if we have molecular graphs to work with, make sure the connectivities are\n    # isomorphic to each other. Otherwise, we will decide only based on distance.\n    # (which is bad!!)\n    if nodes_have_graph:\n        r_passes = r_passes_opt and _is_connectivity_identical(r_traj[-1], chain[0])\n        p_passes = p_passes_opt and _is_connectivity_identical(p_traj[-1], chain[-1])\n    else:\n        r_passes = r_passes_opt\n        p_passes = p_passes_opt\n\n    n_grad_calls = len(r_traj) + len(p_traj)\n    if r_passes and p_passes:\n        return True, n_grad_calls\n    else:\n        return False, n_grad_calls\n</code></pre>"},{"location":"inputs/","title":"Inputs","text":""},{"location":"inputs/#neb_dynamics.inputs.ChainInputs","title":"<code>ChainInputs</code>  <code>dataclass</code>","text":"<p>Object containing parameters relevant to chain. <code>k</code>: maximum spring constant. <code>delta_k</code>: parameter to use for calculating energy weighted spring constants         see: https://pubs.acs.org/doi/full/10.1021/acs.jctc.1c00462</p> <p><code>node_class</code>: type of node to use <code>do_parallel</code>: whether to compute gradients and energies in parallel <code>use_geodesic_interpolation</code>: whether to use GI in interpolations <code>friction_optimal_gi</code>: whether to optimize 'friction' parameter when running GI</p> <p><code>do_chain_biasing</code>: whether to use chain biasing (Under Development, not ready for use) <code>cb</code>: Chain biaser object (Under Development, not ready for use)</p> <p><code>node_freezing</code>: whether to freeze nodes in NEB convergence <code>node_conf_en_thre</code>: float = threshold for energy difference (kcal/mol) of geometries                         for identifying identical conformers</p> <p><code>tc_model_method</code>: 'method' parameter for electronic structure calculations <code>tc_model_basis</code>: 'method' parameter for electronic structure calculations <code>tc_kwds</code>: keyword arguments for electronic structure calculations</p> Source code in <code>neb_dynamics/inputs.py</code> <pre><code>@dataclass\nclass ChainInputs:\n    \"\"\"\n    Object containing parameters relevant to chain.\n    `k`: maximum spring constant.\n    `delta_k`: parameter to use for calculating energy weighted spring constants\n            see: https://pubs.acs.org/doi/full/10.1021/acs.jctc.1c00462\n\n    `node_class`: type of node to use\n    `do_parallel`: whether to compute gradients and energies in parallel\n    `use_geodesic_interpolation`: whether to use GI in interpolations\n    `friction_optimal_gi`: whether to optimize 'friction' parameter when running GI\n\n    `do_chain_biasing`: whether to use chain biasing (Under Development, not ready for use)\n    `cb`: Chain biaser object (Under Development, not ready for use)\n\n    `node_freezing`: whether to freeze nodes in NEB convergence\n    `node_conf_en_thre`: float = threshold for energy difference (kcal/mol) of geometries\n                            for identifying identical conformers\n\n    `tc_model_method`: 'method' parameter for electronic structure calculations\n    `tc_model_basis`: 'method' parameter for electronic structure calculations\n    `tc_kwds`: keyword arguments for electronic structure calculations\n    \"\"\"\n\n    k: float = 0.1\n    delta_k: float = 0.0\n\n    node_class: Node = Node\n    do_parallel: bool = True\n    use_geodesic_interpolation: bool = True\n    friction_optimal_gi: bool = True\n\n    node_freezing: bool = True\n\n    node_rms_thre: float = 1.0  # Bohr\n    node_ene_thre: float = 1.0  # kcal/mol\n\n    def copy(self) -&gt; ChainInputs:\n        return ChainInputs(**self.__dict__)\n</code></pre>"},{"location":"inputs/#neb_dynamics.inputs.GIInputs","title":"<code>GIInputs</code>  <code>dataclass</code>","text":"<p>Inputs for geodesic interpolation. See         geodesic interpolation             for details.</p> <p><code>nimages</code>: number of images to use (default: 15)</p> <p><code>friction</code>: value for friction parameter. influences the penalty for         pairwise distances becoming too large. (default: 0.01)</p> <p><code>nudge</code>: value for nudge parameter. (default: 0.001)</p> <p><code>extra_kwds</code>: dictionary containing other keywords geodesic interpolation might use.</p> Source code in <code>neb_dynamics/inputs.py</code> <pre><code>@dataclass\nclass GIInputs:\n    \"\"\"\n    Inputs for geodesic interpolation. See \\\n        [geodesic interpolation](https://pubs.aip.org/aip/jcp/article/150/16/164103/198363/Geodesic-interpolation-for-reaction-pathways) \\\n            for details.\n\n    `nimages`: number of images to use (default: 15)\n\n    `friction`: value for friction parameter. influences the penalty for \\\n        pairwise distances becoming too large. (default: 0.01)\n\n    `nudge`: value for nudge parameter. (default: 0.001)\n\n    `extra_kwds`: dictionary containing other keywords geodesic interpolation might use.\n    \"\"\"\n\n    nimages: int = 15\n    friction: float = 0.01\n    nudge: float = 0.001\n    extra_kwds: dict = field(default_factory=dict)\n\n    def copy(self) -&gt; GIInputs:\n        return GIInputs(**self.__dict__)\n</code></pre>"},{"location":"inputs/#neb_dynamics.inputs.NEBInputs","title":"<code>NEBInputs</code>  <code>dataclass</code>","text":"<p>Object containing inputs relating to NEB convergence. <code>tol</code>: tolerace for optimizations (Hartrees)</p> <p><code>climb</code>: whether to use climbing image NEB</p> <p><code>en_thre</code>: energy difference threshold. (default: tol/450)</p> <p><code>rms_grad_thre</code>: RMS of perpendicular gradient threhsold (default: tol)</p> <p><code>max_rms_grad_thre</code>: maximum(RMS) of perpedicular gradients threshold (default: tol*2.5)</p> <p><code>ts_grad_thre</code>= infinity norm of TS node threshold (default: tol*2.5)</p> <p><code>ts_spring_thre</code>= infinity norm of spring forces of triplet around TS node (default: tol * 1.5),</p> <p><code>skip_identical_graphs</code>: whether to skip minimizations where endpoints have identical graphs</p> <p><code>early_stop_force_thre</code>: infinity norm of TS node early stop check threshold         (default: 0.0 | i.e. no early stop check)</p> <p><code>negative_steps_thre</code>: number of steps chain can oscillate until the step size is halved (default: 10)</p> <p><code>max_steps</code>: maximum number of NEB steps allowed (default: 1000)</p> <p><code>v</code>: whether to be verbose (default: True)</p> <p><code>preopt_with_xtb</code>: whether to preconverge a chain using XTB (default: False)</p> Source code in <code>neb_dynamics/inputs.py</code> <pre><code>@dataclass\nclass NEBInputs:\n    \"\"\"\n    Object containing inputs relating to NEB convergence.\n    `tol`: tolerace for optimizations (Hartrees)\n\n    `climb`: whether to use climbing image NEB\n\n    `en_thre`: energy difference threshold. (default: tol/450)\n\n    `rms_grad_thre`: RMS of perpendicular gradient threhsold (default: tol)\n\n    `max_rms_grad_thre`: maximum(RMS) of perpedicular gradients threshold (default: tol*2.5)\n\n    `ts_grad_thre`= infinity norm of TS node threshold (default: tol*2.5)\n\n    `ts_spring_thre`= infinity norm of spring forces of triplet around TS node (default: tol * 1.5),\n\n    `skip_identical_graphs`: whether to skip minimizations where endpoints have identical graphs\n\n    `early_stop_force_thre`: infinity norm of TS node early stop check threshold \\\n        (default: 0.0 | i.e. no early stop check)\n\n    `negative_steps_thre`: number of steps chain can oscillate until the step size is halved (default: 10)\n\n    `max_steps`: maximum number of NEB steps allowed (default: 1000)\n\n    `v`: whether to be verbose (default: True)\n\n    `preopt_with_xtb`: whether to preconverge a chain using XTB (default: False)\n    \"\"\"\n\n    tol: float = 0.002\n    climb: bool = False\n    en_thre: float = None\n    rms_grad_thre: float = None\n    max_rms_grad_thre: float = None\n    skip_identical_graphs: bool = True\n\n    grad_thre: float = None\n    ts_grad_thre: float = None\n    ts_spring_thre: float = None\n    barrier_thre: float = 0.1  # kcal/mol\n\n    early_stop_force_thre: float = 0.0\n    early_stop_chain_rms_thre: float = 0.0\n    early_stop_corr_thre: float = 10.0\n    early_stop_still_steps_thre: int = 100\n\n    negative_steps_thre: int = 10\n\n    max_steps: float = 1000\n\n    v: bool = False\n\n    preopt_with_xtb: bool = False\n    pygsm_kwds: dict = field(default_factory=dict)\n    fneb_kwds: dict = field(default_factory=dict)\n\n    def __post_init__(self):\n        if self.en_thre is None:\n            self.en_thre = self.tol / 450\n\n        if self.rms_grad_thre is None:\n            self.rms_grad_thre = self.tol\n\n        if self.grad_thre is None:\n            self.grad_thre = self.tol / 2\n\n        if self.ts_grad_thre is None:\n            self.ts_grad_thre = self.tol * 5 / 2\n\n        if self.ts_spring_thre is None:\n            self.ts_spring_thre = self.tol * 5 / 2\n\n        if self.max_rms_grad_thre is None:\n            self.max_rms_grad_thre = self.tol * 5 / 2\n\n    def copy(self) -&gt; NEBInputs:\n        return NEBInputs(**self.__dict__)\n</code></pre>"},{"location":"msmep/","title":"msmep","text":"<p>The following tutorial shows how to use the Multi Step Minimum Energy Path (MSMEP) object. <pre><code>::: notebooks/example_cases/neb_tutorial.py\n</code></pre></p>"},{"location":"neb/","title":"Neb","text":"<p>               Bases: <code>PathMinimizer</code></p> <p>Class for running, storing, and visualizing nudged elastic band minimizations. Main functions to use are: - self.optimize_chain() - self.plot_opt_history()</p> <p>Note</p> <p>Colton said this rocks</p> Source code in <code>neb_dynamics/neb.py</code> <pre><code>@dataclass\nclass NEB(PathMinimizer):\n    \"\"\"\n    Class for running, storing, and visualizing nudged elastic band minimizations.\n    Main functions to use are:\n    - self.optimize_chain()\n    - self.plot_opt_history()\n\n    !!! Note\n        Colton said this rocks\n\n    \"\"\"\n\n    initial_chain: Chain\n    optimizer: Optimizer\n    parameters: NEBInputs\n    engine: Engine\n\n    optimized: Chain = None\n    chain_trajectory: list[Chain] = field(default_factory=list)\n    gradient_trajectory: list[np.array] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.n_steps_still_chain = 0\n        self.grad_calls_made = 0\n        self.geom_grad_calls_made = 0\n\n    def set_climbing_nodes(self, chain: Chain) -&gt; None:\n        \"\"\"Iterates through chain and sets the nodes that should climb.\n\n        Args:\n            chain: chain to set inputs for\n        \"\"\"\n        if self.parameters.climb:\n            inds_maxima = [chain.energies.argmax()]\n\n            if self.parameters.v &gt; 0:\n                print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n            for ind in inds_maxima:\n                chain[ind].do_climb = True\n\n    def _do_early_stop_check(self, chain: Chain) -&gt; Tuple[bool, ElemStepResults]:\n        \"\"\"\n        this function calls geometry minimizations to verify if\n        chain is an elementary step\n\n        Args:\n            chain (Chain): chain to check\n\n        Returns:\n            tuple(boolean, ElemStepResults) : boolean of whether\n                    to stop early, and an ElemStepResults objects\n        \"\"\"\n\n        elem_step_results = check_if_elem_step(inp_chain=chain, engine=self.engine)\n\n        if not elem_step_results.is_elem_step:\n            print(\"\\nStopped early because chain is not an elementary step.\")\n            print(f\"Split chain based on: {elem_step_results.splitting_criterion}\")\n            self.optimized = chain\n            return True, elem_step_results\n\n        else:\n            self.n_steps_still_chain = 0\n            return False, elem_step_results\n\n    def _check_early_stop(self, chain: Chain):\n        \"\"\"\n        this function computes chain distances and checks gradient\n        values in order to decide whether the expensive minimization of\n        the chain should be done.\n        \"\"\"\n        import neb_dynamics.chainhelpers as ch\n\n        ind_ts_guess = np.argmax(chain.energies)\n        ts_guess_grad = np.amax(np.abs(ch.get_g_perps(chain)[ind_ts_guess]))\n\n        if ts_guess_grad &lt; self.parameters.early_stop_force_thre:\n\n            new_params = self.parameters.copy()\n            new_params.early_stop_force_thre = 0.0\n            self.parameters = new_params\n\n            # going to set climbing nodes when checking early stop\n            if self.parameters.climb:\n                self.set_climbing_nodes(chain=chain)\n                self.parameters.climb = False  # no need to set climbing nodes again\n\n            stop_early, elem_step_results = self._do_early_stop_check(chain)\n\n            self.parameters.early_stop_force_thre = (\n                0.0  # setting it to 0 so we don't check it over and over\n            )\n            return stop_early, elem_step_results\n\n        else:\n            return False, ElemStepResults(\n                is_elem_step=None,\n                is_concave=None,\n                splitting_criterion=None,\n                minimization_results=[],\n                number_grad_calls=0,\n            )\n\n    # @Jan: This should be a more general function so that the\n    # lower level of theory can be whatever the user wants.\n    def _do_xtb_preopt(self, chain) -&gt; Chain:  #\n        \"\"\"\n        This function will loosely minimize an input chain using the GFN2-XTB method,\n        then return a new chain which can be used as an initial guess for a higher\n        level of theory calculation\n        \"\"\"\n\n        xtb_params = chain.parameters.copy()\n        xtb_params.node_class = Node\n        chain_traj = chain.to_trajectory()\n        xtb_chain = Chain.from_traj(chain_traj, parameters=xtb_params)\n        xtb_nbi = NEBInputs(\n            tol=self.parameters.tol * 10, v=True, preopt_with_xtb=False, max_steps=1000\n        )\n\n        opt_xtb = VelocityProjectedOptimizer(timestep=1)\n        n = NEB(initial_chain=xtb_chain, parameters=xtb_nbi, optimizer=opt_xtb)\n        try:\n            _ = n.optimize_chain()\n            print(f\"\\nConverged an xtb chain in {len(n.chain_trajectory)} steps\")\n        except Exception:\n            print(f\"\\nCompleted {len(n.chain_trajectory)} xtb steps. Did not converge.\")\n\n        xtb_seed_tr = n.chain_trajectory[-1].to_trajectory()\n        xtb_seed_tr.update_tc_parameters(chain[0].tdstructure)\n\n        xtb_seed = Chain.from_traj(xtb_seed_tr, parameters=chain.parameters.copy())\n        xtb_seed.gradients  # calling it to cache the values\n\n        return xtb_seed\n\n    def optimize_chain(self) -&gt; ElemStepResults:\n        \"\"\"\n        Main function. After an NEB object has been created, running this function will\n        minimize the chain and return the elementary step results from the final minimized chain.\n\n        Running this function will populate the `.chain_trajectory` object variable, which\n        contains the history of the chains minimized. Once it is completed, you can use\n        `.plot_opt_history()` to view the optimization over time.\n\n        Args:\n            self: initialized NEB object\n        Raises:\n            NoneConvergedException: If chain did not converge in alloted steps.\n        \"\"\"\n        import neb_dynamics.chainhelpers as ch\n\n        nsteps = 1\n        nsteps_negative_grad_corr = 0\n\n        if self.parameters.preopt_with_xtb:\n            chain_previous = self._do_xtb_preopt(self.initial_chain)\n            self.chain_trajectory.append(chain_previous)\n\n            stop_early, elem_step_results = self._do_early_stop_check(chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n        else:\n            chain_previous = self.initial_chain.copy()\n            self.chain_trajectory.append(chain_previous)\n        chain_previous._zero_velocity()\n\n        while nsteps &lt; self.parameters.max_steps + 1:\n            if nsteps &gt; 1:\n                stop_early, elem_step_results = self._check_early_stop(chain_previous)\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                if stop_early:\n                    return elem_step_results\n            try:\n                new_chain = self.update_chain(chain=chain_previous)\n            except ExternalProgramError:\n                elem_step_results = check_if_elem_step(\n                    inp_chain=chain_previous, engine=self.engine\n                )\n                raise ElectronicStructureError(msg=\"QCOP failed.\")\n\n            max_rms_grad_val = np.amax(new_chain.rms_gperps)\n            ind_ts_guess = np.argmax(new_chain.energies)\n            ts_guess_grad = np.amax(np.abs(ch.get_g_perps(new_chain)[ind_ts_guess]))\n            converged = chain_converged(\n                chain_prev=chain_previous,\n                chain_new=new_chain,\n                parameters=self.parameters,\n            )\n            if converged and self.parameters.v:\n                print(\"\\nConverged!\")\n\n            n_nodes_frozen = 0\n            for node in new_chain:\n                if node.converged:\n                    n_nodes_frozen += 1\n\n            grad_calls_made = len(new_chain) - n_nodes_frozen\n            self.grad_calls_made += grad_calls_made\n\n            grad_corr = ch._gradient_correlation(new_chain, chain_previous)\n            if grad_corr &lt; 0:\n                nsteps_negative_grad_corr += 1\n            else:\n                nsteps_negative_grad_corr = 0\n\n            if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n                print(\"\\nstep size causing oscillations. decreasing by 50%\")\n                self.optimizer.timestep *= 0.5\n                nsteps_negative_grad_corr = 0\n\n            if self.parameters.v:\n\n                print(\n                    f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                        max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                            {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                                  {n_nodes_frozen} // {grad_corr}{' '*20}\",\n                    end=\"\\r\",\n                )\n                sys.stdout.flush()\n\n            self.chain_trajectory.append(new_chain)\n            self.gradient_trajectory.append(new_chain.gradients)\n\n            if converged:\n                if self.parameters.v:\n                    print(\"\\nChain converged!\")\n\n                elem_step_results = check_if_elem_step(\n                    inp_chain=new_chain, engine=self.engine\n                )\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                self.optimized = new_chain\n                return elem_step_results\n\n            chain_previous = new_chain\n            nsteps += 1\n\n        new_chain = self.update_chain(chain=chain_previous)\n        if not chain_converged(\n            chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters\n        ):\n            raise NoneConvergedException(\n                trajectory=self.chain_trajectory,\n                msg=f\"\\nChain did not converge at step {nsteps}\",\n                obj=self,\n            )\n\n    def _update_cache(\n        self, chain: Chain, gradients: NDArray, energies: NDArray\n    ) -&gt; None:\n        \"\"\"\n        will update the `_cached_energy` and `_cached_gradient` attributes in the chain\n        nodes based on the input `gradients` and `energies`\n        \"\"\"\n        from neb_dynamics.fakeoutputs import FakeQCIOOutput, FakeQCIOResults\n\n        for node, grad, ene in zip(chain, gradients, energies):\n            res = FakeQCIOResults(energy=ene, gradient=grad)\n            outp = FakeQCIOOutput(results=res)\n            node._cached_result = outp\n            node._cached_energy = ene\n            node._cached_gradient = grad\n\n    def update_chain(self, chain: Chain) -&gt; Chain:\n        import neb_dynamics.chainhelpers as ch\n\n        grads = self.engine.compute_gradients(chain)\n        enes = self.engine.compute_energies(chain)\n        self._update_cache(chain, grads, enes)\n\n        grad_step = ch.compute_NEB_gradient(chain)\n        new_chain = self.optimizer.optimize_step(chain=chain, chain_gradients=grad_step)\n        # need to copy the gradients from the converged nodes\n        for new_node, old_node in zip(new_chain.nodes, chain.nodes):\n            if old_node.converged:\n                new_node._cached_result = old_node._cached_result\n                new_node._cached_energy = old_node._cached_energy\n                new_node._cached_gradient = old_node._cached_gradient\n\n        self.engine.compute_gradients(new_chain)\n\n        return new_chain\n\n    def plot_chain_distances(self):\n        import neb_dynamics.chainhelpers as ch\n\n        distances = ch._calculate_chain_distances(self.chain_trajectory)\n\n        fs = 18\n        s = 8\n\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n\n        plt.plot(distances, \"o-\")\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylabel(\"Distance to previous chain\", fontsize=fs)\n        plt.xlabel(\"Chain id\", fontsize=fs)\n\n        plt.show()\n\n    def plot_grad_delta_mag_history(self):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i - 1]\n            projs.append(prev_chain._gradient_delta_mags(chain))\n\n        plt.plot(projs)\n        plt.ylabel(\"NEB |\u2206gradient|\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        # plt.ylim(0,1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_projector_history(self, var=\"gradients\"):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i - 1]\n            if var == \"gradients\":\n                projs.append(prev_chain._gradient_correlation(chain))\n            elif var == \"tangents\":\n                projs.append(prev_chain._tangent_correlations(chain))\n            else:\n                raise ValueError(f\"Unrecognized var: {var}\")\n        plt.plot(projs)\n        plt.ylabel(f\"NEB {var} correlation\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylim(-1.1, 1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_convergence_metrics(self, do_indiv=False):\n        ct = self.chain_trajectory\n\n        avg_rms_gperp = []\n        max_rms_gperp = []\n        avg_rms_g = []\n        barr_height = []\n        ts_gperp = []\n\n        for ind in range(1, len(ct)):\n            avg_rms_g.append(sum(ct[ind].rms_gradients[1:-1]) / (len(ct[ind]) - 2))\n            avg_rms_gperp.append(sum(ct[ind].rms_gperps[1:-1]) / (len(ct[ind]) - 2))\n            max_rms_gperp.append(max(ct[ind].rms_gperps))\n            barr_height.append(abs(ct[ind].get_eA_chain() - ct[ind - 1].get_eA_chain()))\n            ts_node_ind = ct[ind].energies.argmax()\n            ts_node_gperp = np.max(ch.get_g_perps(ct[ind])[ts_node_ind])\n            ts_gperp.append(ts_node_gperp)\n\n        if do_indiv:\n\n            def plot_with_hline(data, label, y_hline, hline_label, hline_color, ylabel):\n                f, ax = plt.subplots()\n                plt.plot(data, label=label)\n                plt.ylabel(ylabel)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(\n                    y=y_hline,\n                    xmin=xmin,\n                    xmax=xmax,\n                    label=hline_label,\n                    linestyle=\"--\",\n                    color=hline_color,\n                )\n                f.legend()\n                plt.show()\n\n            # Plot RMS Grad$_{\\perp}$\n            plot_with_hline(\n                avg_rms_gperp,\n                label=\"RMS Grad$_{\\perp}$\",\n                y_hline=self.parameters.rms_grad_thre,\n                hline_label=\"rms_grad_thre\",\n                hline_color=\"blue\",\n                ylabel=\"Gradient data\",\n            )\n\n            # Plot Max RMS Grad$_{\\perp}$\n            plot_with_hline(\n                max_rms_gperp,\n                label=\"Max RMS Grad$_{\\perp}$\",\n                y_hline=self.parameters.max_rms_grad_thre,\n                hline_label=\"max_rms_grad_thre\",\n                hline_color=\"orange\",\n                ylabel=\"Gradient data\",\n            )\n\n            # Plot TS gperp\n            plot_with_hline(\n                ts_gperp,\n                label=\"TS gperp\",\n                y_hline=self.parameters.ts_grad_thre,\n                hline_label=\"ts_grad_thre\",\n                hline_color=\"green\",\n                ylabel=\"Gradient data\",\n            )\n\n            # Plot barrier height\n            plot_with_hline(\n                barr_height,\n                label=\"barr_height_delta\",\n                y_hline=self.parameters.barrier_thre,\n                hline_label=\"barrier_thre\",\n                hline_color=\"purple\",\n                ylabel=\"Barrier height data\",\n            )\n\n        else:\n            # Define the data and parameters\n            data_list = [\n                (\n                    avg_rms_gperp,\n                    \"RMS Grad$_{\\perp}$\",\n                    self.parameters.rms_grad_thre,\n                    \"rms_grad_thre\",\n                    \"blue\",\n                ),\n                (\n                    max_rms_gperp,\n                    \"Max RMS Grad$_{\\perp}$\",\n                    self.parameters.max_rms_grad_thre,\n                    \"max_rms_grad_thre\",\n                    \"orange\",\n                ),\n                (\n                    ts_gperp,\n                    \"TS gperp\",\n                    self.parameters.ts_grad_thre,\n                    \"ts_grad_thre\",\n                    \"green\",\n                ),\n            ]\n\n            # Create subplots\n            f, ax = plt.subplots()\n\n            # Plot the gradient data\n            for data, label, hline, hline_label, color in data_list:\n                ax.plot(data, label=label)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(\n                    y=hline,\n                    xmin=xmin,\n                    xmax=xmax,\n                    label=hline_label,\n                    linestyle=\"--\",\n                    color=color,\n                )\n\n            # Set y-axis label for gradient data\n            ax.set_ylabel(\"Gradient data\")\n\n            # Create a second y-axis for barrier height data\n            ax2 = ax.twinx()\n            ax2.plot(barr_height, \"o--\", label=\"barr_height_delta\", color=\"purple\")\n            ax2.set_ylabel(\"Barrier height data\")\n            ax2.hlines(\n                y=self.parameters.barrier_thre,\n                xmin=xmin,\n                xmax=xmax,\n                label=\"barrier_thre\",\n                linestyle=\"--\",\n                color=\"purple\",\n            )\n\n            # Show legends and plot\n            f.legend(loc=\"upper left\")\n            plt.show()\n\n    def read_from_disk(\n        fp: Path,\n        history_folder: Path = None,\n        chain_parameters=ChainInputs(),\n        neb_parameters=NEBInputs(),\n        gi_parameters=GIInputs(),\n        optimizer=VelocityProjectedOptimizer(),\n        engine: Engine = None,\n    ):\n        if isinstance(fp, str):\n            fp = Path(fp)\n\n        if history_folder is None:\n            history_folder = fp.parent / (str(fp.stem) + \"_history\")\n\n        if not history_folder.exists():\n            raise ValueError(\"No history exists for this. Cannot load object.\")\n        else:\n            history_files = list(history_folder.glob(\"*.xyz\"))\n            history = [\n                Chain.from_xyz(\n                    history_folder / f\"traj_{i}.xyz\", parameters=chain_parameters\n                )\n                for i, _ in enumerate(history_files)\n            ]\n\n        n = NEB(\n            initial_chain=history[0],\n            parameters=neb_parameters,\n            optimized=history[-1],\n            chain_trajectory=history,\n            optimizer=optimizer,\n            engine=engine,\n        )\n        return n\n</code></pre>"},{"location":"neb/#neb_dynamics.neb.NEB.optimize_chain","title":"<code>optimize_chain()</code>","text":"<p>Main function. After an NEB object has been created, running this function will minimize the chain and return the elementary step results from the final minimized chain.</p> <p>Running this function will populate the <code>.chain_trajectory</code> object variable, which contains the history of the chains minimized. Once it is completed, you can use <code>.plot_opt_history()</code> to view the optimization over time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>initialized NEB object</p> required <p>Raises:     NoneConvergedException: If chain did not converge in alloted steps.</p> Source code in <code>neb_dynamics/neb.py</code> <pre><code>def optimize_chain(self) -&gt; ElemStepResults:\n    \"\"\"\n    Main function. After an NEB object has been created, running this function will\n    minimize the chain and return the elementary step results from the final minimized chain.\n\n    Running this function will populate the `.chain_trajectory` object variable, which\n    contains the history of the chains minimized. Once it is completed, you can use\n    `.plot_opt_history()` to view the optimization over time.\n\n    Args:\n        self: initialized NEB object\n    Raises:\n        NoneConvergedException: If chain did not converge in alloted steps.\n    \"\"\"\n    import neb_dynamics.chainhelpers as ch\n\n    nsteps = 1\n    nsteps_negative_grad_corr = 0\n\n    if self.parameters.preopt_with_xtb:\n        chain_previous = self._do_xtb_preopt(self.initial_chain)\n        self.chain_trajectory.append(chain_previous)\n\n        stop_early, elem_step_results = self._do_early_stop_check(chain_previous)\n        self.geom_grad_calls_made += elem_step_results.number_grad_calls\n        if stop_early:\n            return elem_step_results\n    else:\n        chain_previous = self.initial_chain.copy()\n        self.chain_trajectory.append(chain_previous)\n    chain_previous._zero_velocity()\n\n    while nsteps &lt; self.parameters.max_steps + 1:\n        if nsteps &gt; 1:\n            stop_early, elem_step_results = self._check_early_stop(chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n        try:\n            new_chain = self.update_chain(chain=chain_previous)\n        except ExternalProgramError:\n            elem_step_results = check_if_elem_step(\n                inp_chain=chain_previous, engine=self.engine\n            )\n            raise ElectronicStructureError(msg=\"QCOP failed.\")\n\n        max_rms_grad_val = np.amax(new_chain.rms_gperps)\n        ind_ts_guess = np.argmax(new_chain.energies)\n        ts_guess_grad = np.amax(np.abs(ch.get_g_perps(new_chain)[ind_ts_guess]))\n        converged = chain_converged(\n            chain_prev=chain_previous,\n            chain_new=new_chain,\n            parameters=self.parameters,\n        )\n        if converged and self.parameters.v:\n            print(\"\\nConverged!\")\n\n        n_nodes_frozen = 0\n        for node in new_chain:\n            if node.converged:\n                n_nodes_frozen += 1\n\n        grad_calls_made = len(new_chain) - n_nodes_frozen\n        self.grad_calls_made += grad_calls_made\n\n        grad_corr = ch._gradient_correlation(new_chain, chain_previous)\n        if grad_corr &lt; 0:\n            nsteps_negative_grad_corr += 1\n        else:\n            nsteps_negative_grad_corr = 0\n\n        if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n            print(\"\\nstep size causing oscillations. decreasing by 50%\")\n            self.optimizer.timestep *= 0.5\n            nsteps_negative_grad_corr = 0\n\n        if self.parameters.v:\n\n            print(\n                f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                    max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                        {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                              {n_nodes_frozen} // {grad_corr}{' '*20}\",\n                end=\"\\r\",\n            )\n            sys.stdout.flush()\n\n        self.chain_trajectory.append(new_chain)\n        self.gradient_trajectory.append(new_chain.gradients)\n\n        if converged:\n            if self.parameters.v:\n                print(\"\\nChain converged!\")\n\n            elem_step_results = check_if_elem_step(\n                inp_chain=new_chain, engine=self.engine\n            )\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            self.optimized = new_chain\n            return elem_step_results\n\n        chain_previous = new_chain\n        nsteps += 1\n\n    new_chain = self.update_chain(chain=chain_previous)\n    if not chain_converged(\n        chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters\n    ):\n        raise NoneConvergedException(\n            trajectory=self.chain_trajectory,\n            msg=f\"\\nChain did not converge at step {nsteps}\",\n            obj=self,\n        )\n</code></pre>"},{"location":"neb/#neb_dynamics.neb.NEB.set_climbing_nodes","title":"<code>set_climbing_nodes(chain)</code>","text":"<p>Iterates through chain and sets the nodes that should climb.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>chain to set inputs for</p> required Source code in <code>neb_dynamics/neb.py</code> <pre><code>def set_climbing_nodes(self, chain: Chain) -&gt; None:\n    \"\"\"Iterates through chain and sets the nodes that should climb.\n\n    Args:\n        chain: chain to set inputs for\n    \"\"\"\n    if self.parameters.climb:\n        inds_maxima = [chain.energies.argmax()]\n\n        if self.parameters.v &gt; 0:\n            print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n        for ind in inds_maxima:\n            chain[ind].do_climb = True\n</code></pre>"},{"location":"tutorial/","title":"tutorial","text":"<p>This tutorial references ChainInputs, NEBInputs,Chain, Trajectory, TDStructure, NEB and VelocityProjectedOptimizer</p>"},{"location":"tutorial/#running-our-first-neb-calculation-we-are-going-to-calculate-a-pi-bond-torsion","title":"Running our first NEB calculation. We are going to calculate a pi-bond torsion.","text":""},{"location":"tutorial/#1-create-initial-guess","title":"1. Create initial guess","text":""},{"location":"tutorial/#we-will-create-geometrics-using-qcio-then-instantiate-our-nodes","title":"We will create geometrics using QCIO, then instantiate our nodes","text":"<pre><code>from qcio import Structure\nfrom neb_dynamics import StructureNode\n\nstart = Structure.from_smiles(\"C=C\")\n# we can also load in a structure from a file path with:\n# start = Structure.open(\"/path/to/file.xyz\")\n\nstart_node = StructureNode(structure=start)\n\nend_node = start_node.copy()\nend_coords = end_node.coords\nend_coords_swapped = end_coords[[0,1,3,2,4,5],:] # We have swapped the indices of two hydrogens\nend_node = end_node.update_coords(end_coords_swapped)\n</code></pre>"},{"location":"tutorial/#now-we-need-to-optimize-them-to-our-desired-level-of-theory","title":"Now we need to optimize them to our desired level of theory","text":"<pre><code>from neb_dynamics import QCOPEngine, ASEEngine\nfrom xtb.ase.calculator import XTB\n\ncalc = XTB()\neng = ASEEngine(calculator=calc) #QCOPEngine() # Also have ASEEngine if you want to run with ASE calculators\n# QCOPEngine will default to using XTB\n\nstart_opt = eng.compute_geometry_optimization(start_node)\nend_opt = eng.compute_geometry_optimization(end_node)\n</code></pre>"},{"location":"tutorial/#now-we-need-to-interpolate-between-our-endpoints","title":"Now we need to interpolate between our endpoints","text":"<pre><code>import neb_dynamics.chainhelpers as ch\nfrom neb_dynamics.inputs import ChainInputs\n\ncni = ChainInputs(k=0.1, delta_k=0.09) # energy weighted spring constants\n# see: https://pubs.acs.org/doi/10.1021/acs.jctc.1c00462\ninitial_chain = ch.run_geodesic([start_node, end_node], chain_inputs=cni, nimages=15)\n</code></pre>"},{"location":"tutorial/#2-lets-set-up-our-neb-optimization","title":"2. Let's set up our NEB optimization","text":""},{"location":"tutorial/#the-neb-object-takes-in-4-parameters","title":"The NEB object takes in 4 parameters:","text":"<ul> <li><code>initial_chain</code>: our initial guess chain object to optimize</li> <li><code>parameters</code>: an NEBInputs object containing the parameters for NEB optimization and convergence</li> <li><code>optimizer</code>: the optimizer to use. We suggest you use <code>VelocityProjectedOptimizer</code> from             <code>neb_dynamics.optimizer.VPO</code></li> <li><code>engine</code>: defines the electronic structure engine to be used <pre><code>from neb_dynamics.neb import NEB\nfrom neb_dynamics.inputs import NEBInputs\n\nnbi = NEBInputs(v=True)\n\nfrom neb_dynamics.optimizers.vpo import VelocityProjectedOptimizer\n\nopt = VelocityProjectedOptimizer(timestep=0.5)\n\nn = NEB(initial_chain=initial_chain, parameters=nbi, optimizer=opt, engine=eng)\n\nelem_step_results = n.optimize_chain()\n\nn.plot_opt_history(1)\n\nch.visualize_chain(n.optimized)\n</code></pre></li> </ul>"}]}