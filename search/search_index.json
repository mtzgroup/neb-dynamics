{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neb Dynamics","text":""},{"location":"#install","title":"Install","text":"<ol> <li><code>pip install \"git+https://github.com/mtzgroup/neb-dynamics.git\"</code></li> </ol>"},{"location":"#maintainers","title":"Maintainers","text":"<p>If you have any questions, please ask: Jan</p>"},{"location":"#tips","title":"Tips","text":"<ul> <li>If using XTB, setting <code>OMP_NUM_THREADS=1</code> can speed up the process when the individual calculation will not benefit from paralellization.</li> </ul>"},{"location":"Tutorial/","title":"Tutorial","text":"<p>This tutorial references ChainInputs, NEBInputs,Chain, Trajectory, TDStructure, NEB and VelocityProjectedOptimizer</p>"},{"location":"Tutorial/#running-neb-using-terachem-in-chemcloud","title":"Running NEB using TeraChem in ChemCloud","text":"<pre><code># Running our first NEB calculation. Naturally, we are going to calculate a pi-bond torsion.\n\n# # 1. Create initial guess\n#\n# ### We will create endpoints as we did the previous tutorials.\n\nfrom neb_dynamics.tdstructure import TDStructure\nfrom neb_dynamics.trajectory import Trajectory\n\nstart = TDStructure.from_smiles(\"C=C\")\nend = start.copy()\n\n# we can also load in a structure from a file path with:\n# start = TDStructure.from_xyz(\"/path/to/file.xyz\")\nend_coords = end.coords\nend_coords_swapped = end_coords[[0,1,3,2,4,5],:] # We have swapped the indices of two hydrogens\nend = end.update_coords(end_coords_swapped)\n# we can also load in a structure from a file path with:\n# end = TDStructure.from_xyz(\"/path/to/file.xyz\")\n\n# ### Now we need to optimize them to our desired level of theory\n\nstart_opt = start.xtb_geom_optimization()\n# start_opt = start.tc_geom_optimization() # use this one if you want to run TeraChem in ChemCloud\nend_opt = end.xtb_geom_optimization()\n# end_opt = end.tc_geom_optimization() # use this one if you want to run TeraChem in ChemCloud\n\n# ### Now we need to interpolate between our endpoints\n\ntr = Trajectory([start_opt, end_opt]).run_geodesic(nimages=10)\n\n# ### Finally, let's create our Chain object\n\nfrom neb_dynamics.Chain import Chain\nfrom neb_dynamics.Inputs import ChainInputs\n\ncni = ChainInputs(k=0.1, delta_k=0.09)\ninitial_chain = Chain.from_traj(tr, parameters=cni)\n\n# # 2. Let's set up our NEB optimization\n\nfrom neb_dynamics.NEB import NEB\nfrom neb_dynamics.Inputs import NEBInputs\n\n# NEB\n\n# The NEB object takes in 3 parameters:\n# * initial_chain: our initial guess chain object to optimize\n# * parameters: an NEBInputs object containing the parameters for NEB optimization and convergence\n# * optimizer: the optimizer to use. We suggest you use `VelocityProjectedOptimizer` from\n#             `neb_dynamics.optimizer.VPO`\n\nnbi = NEBInputs(v=True, tol=0.0001, ts_spring_thre=0.0001, climb=True)\n\nfrom neb_dynamics.optimizers.VPO import VelocityProjectedOptimizer\n\nopt = VelocityProjectedOptimizer(timestep=0.5)\n\nn = NEB(initial_chain=initial_chain, parameters=nbi, optimizer=opt)\n\n_ = n.optimize_chain()\n\nn.plot_opt_history(1)\n\nprint(n.optimized.get_ts_guess().coords)\n</code></pre>"},{"location":"elementarystep/","title":"Elementarystep","text":"<p>this whole module needs to be revamped and integrated with the qcio results objects probably.</p>"},{"location":"elementarystep/#neb_dynamics.elementarystep.ConcavityResults","title":"<code>ConcavityResults</code>  <code>dataclass</code>","text":"<p>Stores results on concavity checks (i.e. whether chain has a \"dip\" that could be        a new minimum)</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass ConcavityResults:\n    \"\"\"\n    Stores results on concavity checks (i.e. whether chain has a \"dip\" that could be\\\n        a new minimum)\n    \"\"\"\n    is_concave: bool\n    minimization_results: list[Node]\n    number_grad_calls: int\n\n    @property\n    def is_not_concave(self):\n        return not self.is_concave\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.ElemStepResults","title":"<code>ElemStepResults</code>  <code>dataclass</code>","text":"<p>Object to build report on minimization from elementary step checks.</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass ElemStepResults:\n    \"\"\"\n    Object to build report on minimization from elementary step checks.\n    \"\"\"\n    is_elem_step: bool\n    is_concave: bool\n    splitting_criterion: str\n    minimization_results: List[Node]\n    number_grad_calls: int\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.IRCResults","title":"<code>IRCResults</code>  <code>dataclass</code>","text":"<p>Stores results on (pseudo)IRC checks</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>@dataclass\nclass IRCResults:\n    \"\"\"Stores results on (pseudo)IRC checks\n    \"\"\"\n    found_reactant: Node\n    found_product: Node\n    number_grad_calls: int\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.check_if_elem_step","title":"<code>check_if_elem_step(inp_chain)</code>","text":"<p>Calculates whether an input chain is an elementary step.</p> <p>Parameters:</p> Name Type Description Default <code>inp_chain</code> <code>Chain</code> <p>input chain to check.</p> required <p>Returns:</p> Name Type Description <code>ElemStepResults</code> <code>ElemStepResults</code> <p>object containing report on chain.</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>def check_if_elem_step(inp_chain: Chain) -&gt; ElemStepResults:\n    \"\"\"Calculates whether an input chain is an elementary step.\n\n    Args:\n        inp_chain (Chain): input chain to check.\n\n    Returns:\n        ElemStepResults: object containing report on chain.\n    \"\"\"\n    n_geom_opt_grad_calls = 0\n    chain = inp_chain.copy()\n    if len(inp_chain) &lt;= 1:\n        return ElemStepResults(\n            is_elem_step=True,\n            is_concave=True,\n            splitting_criterion=None,\n            minimization_results=None,\n            number_grad_calls=0\n        )\n\n    concavity_results = _chain_is_concave(inp_chain)\n    n_geom_opt_grad_calls += concavity_results.number_grad_calls\n\n    if concavity_results.is_not_concave:\n        return ElemStepResults(\n            is_elem_step=False,\n            is_concave=concavity_results.is_concave,\n            splitting_criterion='minima',\n            minimization_results=concavity_results.minimization_results,\n            number_grad_calls=n_geom_opt_grad_calls\n        )\n\n    crude_irc_passed, ngc_approx_elem_step = is_approx_elem_step(\n        chain=inp_chain)\n    n_geom_opt_grad_calls += ngc_approx_elem_step\n\n    if crude_irc_passed:\n        return ElemStepResults(\n            is_elem_step=True,\n            is_concave=concavity_results.is_concave,\n            splitting_criterion=None,\n            minimization_results=[inp_chain[0], inp_chain[-1]],\n            number_grad_calls=n_geom_opt_grad_calls\n        )\n\n    pseu_irc_results = pseudo_irc(chain=inp_chain)\n    n_geom_opt_grad_calls += pseu_irc_results.number_grad_calls\n\n    found_r = pseu_irc_results.found_reactant.is_identical(chain[0])\n    found_p = pseu_irc_results.found_product.is_identical(chain[-1])\n    minimizing_gives_endpoints = found_r and found_p\n\n    elem_step = True if minimizing_gives_endpoints else False\n\n    return ElemStepResults(is_elem_step=elem_step,\n                           is_concave=concavity_results.is_concave,\n                           splitting_criterion='maxima',\n                           minimization_results=[pseu_irc_results.found_reactant, pseu_irc_results.found_product],\n                           number_grad_calls=n_geom_opt_grad_calls\n                           )\n</code></pre>"},{"location":"elementarystep/#neb_dynamics.elementarystep.is_approx_elem_step","title":"<code>is_approx_elem_step(chain, slope_thresh=0.1)</code>","text":"<p>Will do at most 50 steepest descent steps  on geometries neighboring the transition state guess and check whether they are approaching the chain endpoints. If function returns False, the geoms will be fully optimized.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>chain to check on</p> required <code>slope_thresh</code> <code>float</code> <p>Steepest descent optimization will stop when the slope</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>Tuple[bool, int]</code> <p>whether chain seems to be an elementary step</p> Source code in <code>neb_dynamics/elementarystep.py</code> <pre><code>def is_approx_elem_step(chain: Chain, slope_thresh=0.1) -&gt; Tuple[bool, int]:\n    \"\"\"Will do at most 50 steepest descent steps  on geometries neighboring the transition state guess\n    and check whether they are approaching the chain endpoints. If function returns False, the geoms\n    will be fully optimized.\n\n    Args:\n        chain (Chain): chain to check on\n        slope_thresh (float, optional): Steepest descent optimization will stop when the slope\n        of the distances of the minimized geometry to the target endpoint is &gt;= threshold.\n        Defaults to 0.1.\n\n    Returns:\n        bool: whether chain seems to be an elementary step\n    \"\"\"\n    if chain.energies_are_monotonic:\n        return True\n\n    arg_max = np.argmax(chain.energies)\n\n    r_passes_opt, r_traj = _converges_to_an_endpoints(chain=chain, node_index=(arg_max - 1), direction=-1,\n                                                      slope_thresh=slope_thresh)\n    p_passes_opt, p_traj = _converges_to_an_endpoints(chain=chain, node_index=(arg_max + 1), direction=+1,\n                                                      slope_thresh=slope_thresh)\n\n    r_passes = r_passes_opt and r_traj[-1]._is_connectivity_identical(chain[0])\n    p_passes = p_passes_opt and p_traj[-1]._is_connectivity_identical(\n        chain[-1])\n\n    n_grad_calls = len(r_traj) + len(p_traj)\n    if r_passes and p_passes:\n        return True, n_grad_calls\n    else:\n        return False, n_grad_calls\n</code></pre>"},{"location":"inputs/","title":"Inputs","text":""},{"location":"inputs/#neb_dynamics.Inputs.ChainInputs","title":"<code>ChainInputs</code>  <code>dataclass</code>","text":"<p>Object containing parameters relevant to chain. <code>k</code>: maximum spring constant. <code>delta_k</code>: parameter to use for calculating energy weighted spring constants         see: https://pubs.acs.org/doi/full/10.1021/acs.jctc.1c00462</p> <p><code>node_class</code>: type of node to use <code>do_parallel</code>: whether to compute gradients and energies in parallel <code>use_geodesic_interpolation</code>: whether to use GI in interpolations <code>friction_optimal_gi</code>: whether to optimize 'friction' parameter when running GI</p> <p><code>do_chain_biasing</code>: whether to use chain biasing (Under Development, not ready for use) <code>cb</code>: Chain biaser object (Under Development, not ready for use)</p> <p><code>node_freezing</code>: whether to freeze nodes in NEB convergence <code>node_conf_en_thre</code>: float = threshold for energy difference (kcal/mol) of geometries                         for identifying identical conformers</p> <p><code>tc_model_method</code>: 'method' parameter for electronic structure calculations <code>tc_model_basis</code>: 'method' parameter for electronic structure calculations <code>tc_kwds</code>: keyword arguments for electronic structure calculations</p> Source code in <code>neb_dynamics/Inputs.py</code> <pre><code>@dataclass\nclass ChainInputs:\n    \"\"\"\n    Object containing parameters relevant to chain.\n    `k`: maximum spring constant.\n    `delta_k`: parameter to use for calculating energy weighted spring constants\n            see: https://pubs.acs.org/doi/full/10.1021/acs.jctc.1c00462\n\n    `node_class`: type of node to use\n    `do_parallel`: whether to compute gradients and energies in parallel\n    `use_geodesic_interpolation`: whether to use GI in interpolations\n    `friction_optimal_gi`: whether to optimize 'friction' parameter when running GI\n\n    `do_chain_biasing`: whether to use chain biasing (Under Development, not ready for use)\n    `cb`: Chain biaser object (Under Development, not ready for use)\n\n    `node_freezing`: whether to freeze nodes in NEB convergence\n    `node_conf_en_thre`: float = threshold for energy difference (kcal/mol) of geometries\n                            for identifying identical conformers\n\n    `tc_model_method`: 'method' parameter for electronic structure calculations\n    `tc_model_basis`: 'method' parameter for electronic structure calculations\n    `tc_kwds`: keyword arguments for electronic structure calculations\n    \"\"\"\n    k: float = 0.1\n    delta_k: float = 0.0\n\n    node_class: Node = Node3D\n    do_parallel: bool = True\n    use_geodesic_interpolation: bool = True\n    friction_optimal_gi: bool = True\n\n    do_chain_biasing: bool = False\n    cb: ChainBiaser = None\n\n    node_freezing: bool = True\n    node_conf_en_thre: float = 0.5  # kcal/mol\n\n    tc_model_method: str = \"b3lyp\"\n    tc_model_basis: str = \"6-31g\"\n    tc_kwds: dict = field(default_factory=dict)\n\n    def __post_init__(self):\n        if self.do_chain_biasing and self.cb is None:\n            raise ValueError(\n                \"No chain biaser was inputted. Fix this or set 'do_chain_biasing' to False.\"\n            )\n\n    def copy(self):\n        return ChainInputs(**self.__dict__)\n</code></pre>"},{"location":"inputs/#neb_dynamics.Inputs.GIInputs","title":"<code>GIInputs</code>  <code>dataclass</code>","text":"<p>Inputs for geodesic interpolation. See         geodesic interpolation             for details.</p> <p><code>nimages</code>: number of images to use (default: 15)</p> <p><code>friction</code>: value for friction parameter. influences the penalty for         pairwise distances becoming too large. (default: 0.01)</p> <p><code>nudge</code>: value for nudge parameter. (default: 0.001)</p> <p><code>extra_kwds</code>: dictionary containing other keywords geodesic interpolation might use.</p> Source code in <code>neb_dynamics/Inputs.py</code> <pre><code>@dataclass\nclass GIInputs:\n    \"\"\"\n    Inputs for geodesic interpolation. See \\\n        [geodesic interpolation](https://pubs.aip.org/aip/jcp/article/150/16/164103/198363/Geodesic-interpolation-for-reaction-pathways) \\\n            for details.\n\n    `nimages`: number of images to use (default: 15)\n\n    `friction`: value for friction parameter. influences the penalty for \\\n        pairwise distances becoming too large. (default: 0.01)\n\n    `nudge`: value for nudge parameter. (default: 0.001)\n\n    `extra_kwds`: dictionary containing other keywords geodesic interpolation might use.\n    \"\"\"\n    nimages: int = 15\n    friction: float = 0.01\n    nudge: float = 0.001\n    extra_kwds: dict = field(default_factory=dict)\n</code></pre>"},{"location":"inputs/#neb_dynamics.Inputs.NEBInputs","title":"<code>NEBInputs</code>  <code>dataclass</code>","text":"<p>Object containing inputs relating to NEB convergence. <code>tol</code>: tolerace for optimizations (Hartrees)</p> <p><code>climb</code>: whether to use climbing image NEB</p> <p><code>en_thre</code>: energy difference threshold. (default: tol/450)</p> <p><code>rms_grad_thre</code>: RMS of perpendicular gradient threhsold (default: tol)</p> <p><code>max_rms_grad_thre</code>: maximum(RMS) of perpedicular gradients threshold (default: tol*2.5)</p> <p><code>ts_grad_thre</code>= infinity norm of TS node threshold (default: tol*2.5)</p> <p><code>ts_spring_thre</code>= infinity norm of spring forces of triplet around TS node (default: tol * 1.5),</p> <p><code>skip_identical_graphs</code>: whether to skip minimizations where endpoints have identical graphs</p> <p><code>early_stop_force_thre</code>: infinity norm of TS node early stop check threshold (default: 0.0 | i.e. no early stop check)</p> <p><code>negative_steps_thre</code>: number of steps chain can oscillate until the step size is halved (default: 10)</p> <p><code>max_steps</code>: maximum number of NEB steps allowed (default: 1000)</p> <p><code>v</code>: whether to be verbose (default: True)</p> <p><code>preopt_with_xtb</code>: whether to preconverge a chain using XTB (default: False)</p> Source code in <code>neb_dynamics/Inputs.py</code> <pre><code>@dataclass\nclass NEBInputs:\n    \"\"\"\n    Object containing inputs relating to NEB convergence.\n    `tol`: tolerace for optimizations (Hartrees)\n\n    `climb`: whether to use climbing image NEB\n\n    `en_thre`: energy difference threshold. (default: tol/450)\n\n    `rms_grad_thre`: RMS of perpendicular gradient threhsold (default: tol)\n\n    `max_rms_grad_thre`: maximum(RMS) of perpedicular gradients threshold (default: tol*2.5)\n\n    `ts_grad_thre`= infinity norm of TS node threshold (default: tol*2.5)\n\n    `ts_spring_thre`= infinity norm of spring forces of triplet around TS node (default: tol * 1.5),\n\n    `skip_identical_graphs`: whether to skip minimizations where endpoints have identical graphs\n\n    `early_stop_force_thre`: infinity norm of TS node early stop check threshold (default: 0.0 | i.e. no early stop check)\n\n    `negative_steps_thre`: number of steps chain can oscillate until the step size is halved (default: 10)\n\n    `max_steps`: maximum number of NEB steps allowed (default: 1000)\n\n    `v`: whether to be verbose (default: True)\n\n    `preopt_with_xtb`: whether to preconverge a chain using XTB (default: False)\n    \"\"\"\n    tol: float = 0.001 * BOHR_TO_ANGSTROMS\n    climb: bool = False\n    en_thre: float = None\n    rms_grad_thre: float = None\n    max_rms_grad_thre: float = None\n    skip_identical_graphs: bool = True\n\n    grad_thre: float = None\n    ts_grad_thre: float = None\n    ts_spring_thre: float = None\n    barrier_thre: float = 0.1  # kcal/mol\n\n    early_stop_force_thre: float = 0.0\n    early_stop_chain_rms_thre: float = 0.0\n    early_stop_corr_thre: float = 10.0\n    early_stop_still_steps_thre: int = 100\n\n    negative_steps_thre: int = 10\n\n    max_steps: float = 1000\n\n    v: bool = False\n\n    preopt_with_xtb: bool = False\n\n    def __post_init__(self):\n        if self.en_thre is None:\n            self.en_thre = self.tol / 450\n\n        if self.rms_grad_thre is None:\n            self.rms_grad_thre = self.tol\n\n        if self.grad_thre is None:\n            self.grad_thre = self.tol / 2\n\n        if self.ts_grad_thre is None:\n            self.ts_grad_thre = self.tol * 5/2\n\n        if self.ts_spring_thre is None:\n            self.ts_spring_thre = self.tol * 5/2\n\n        if self.max_rms_grad_thre is None:\n            self.max_rms_grad_thre = self.tol * 5/2\n\n    def copy(self):\n        return NEBInputs(**self.__dict__)\n</code></pre>"},{"location":"neb/","title":"Neb","text":"<p>Class for running, storing, and visualizing nudged elastic band minimizations. Main functions to use are: - self.optimize_chain() - self.plot_opt_history()</p> <p>Note</p> <p>Colton said this rocks</p> Source code in <code>neb_dynamics/NEB.py</code> <pre><code>@dataclass\nclass NEB:\n    \"\"\"\n    Class for running, storing, and visualizing nudged elastic band minimizations.\n    Main functions to use are:\n    - self.optimize_chain()\n    - self.plot_opt_history()\n\n    !!! Note\n        Colton said this rocks\n\n    \"\"\"\n    initial_chain: Chain\n    parameters: NEBInputs\n    optimizer: Optimizer\n\n    optimized: Chain = None\n    chain_trajectory: list[Chain] = field(default_factory=list)\n    gradient_trajectory: list[np.array] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.n_steps_still_chain = 0\n        self.grad_calls_made = 0\n        self.geom_grad_calls_made = 0\n\n    def _reset_node_convergence(self, chain) -&gt; None:\n        for node in chain:\n            node.converged = False\n\n    def set_climbing_nodes(self, chain: Chain) -&gt; None:\n        \"\"\"Iterates through chain and sets the nodes that should climb.\n\n        Args:\n            chain: chain to set inputs for\n        \"\"\"\n        if self.parameters.climb:\n            inds_maxima = [chain.energies.argmax()]\n\n            if self.parameters.v &gt; 0:\n                print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n            for ind in inds_maxima:\n                chain[ind].do_climb = True\n\n    def _do_early_stop_check(self, chain: Chain) -&gt; Tuple[bool, ElemStepResults]:\n        \"\"\"\n        this function calls geometry minimizations to verify if\n        chain is an elementary step\n\n        Args:\n            chain (Chain): chain to check\n\n        Returns:\n            tuple(boolean, ElemStepResults) : boolean of whether\n                    to stop early, and an ElemStepResults objects\n        \"\"\"\n\n        elem_step_results = check_if_elem_step(chain)\n\n        if not elem_step_results.is_elem_step:\n            print(\"\\nStopped early because chain is not an elementary step.\")\n            print(\n                f\"Split chain based on: {elem_step_results.splitting_criterion}\")\n            self.optimized = chain\n            return True, elem_step_results\n\n        else:\n            self.n_steps_still_chain = 0\n            return False, elem_step_results\n\n    def _check_early_stop(self, chain: Chain):\n        \"\"\"\n        this function computes chain distances and checks gradient\n        values in order to decide whether the expensive minimization of\n        the chain should be done.\n        \"\"\"\n        ind_ts_guess = np.argmax(chain.energies)\n        ts_guess_grad = np.amax(np.abs(chain.get_g_perps()[ind_ts_guess]))\n\n        if ts_guess_grad &lt;= self.parameters.early_stop_force_thre:\n\n            new_params = self.parameters.copy()\n            new_params.early_stop_force_thre = 0.0\n            self.parameters = new_params\n\n            # going to set climbing nodes when checking early stop\n            if self.parameters.climb:\n                self.set_climbing_nodes(chain=chain)\n                self.parameters.climb = False  # no need to set climbing nodes again\n\n            stop_early, elem_step_results = self._do_early_stop_check(\n                chain)\n            return stop_early, elem_step_results\n\n        else:\n            return False, ElemStepResults(is_elem_step=None,\n                                          is_concave=None,\n                                          splitting_criterion=None,\n                                          minimization_results=[],\n                                          number_grad_calls=0)\n\n    # @Jan: This should be a more general function so that the\n    # lower level of theory can be whatever the user wants.\n    def _do_xtb_preopt(self, chain) -&gt; Chain:  #\n        \"\"\"\n        This function will loosely minimize an input chain using the GFN2-XTB method,\n        then return a new chain which can be used as an initial guess for a higher\n        level of theory calculation\n        \"\"\"\n\n        xtb_params = chain.parameters.copy()\n        xtb_params.node_class = Node3D\n        chain_traj = chain.to_trajectory()\n        xtb_chain = Chain.from_traj(chain_traj, parameters=xtb_params)\n        xtb_nbi = NEBInputs(tol=self.parameters.tol*10,\n                            v=True, preopt_with_xtb=False, max_steps=1000)\n\n        opt_xtb = VelocityProjectedOptimizer(timestep=1)\n        n = NEB(initial_chain=xtb_chain, parameters=xtb_nbi, optimizer=opt_xtb)\n        try:\n            _ = n.optimize_chain()\n            print(\n                f\"\\nConverged an xtb chain in {len(n.chain_trajectory)} steps\")\n        except Exception:\n            print(\n                f\"\\nCompleted {len(n.chain_trajectory)} xtb steps. Did not converge.\")\n\n        xtb_seed_tr = n.chain_trajectory[-1].to_trajectory()\n        xtb_seed_tr.update_tc_parameters(chain[0].tdstructure)\n\n        xtb_seed = Chain.from_traj(\n            xtb_seed_tr, parameters=chain.parameters.copy())\n        xtb_seed.gradients  # calling it to cache the values\n\n        return xtb_seed\n\n    def optimize_chain(self) -&gt; ElemStepResults:\n        \"\"\"\n        Main function. After an NEB object has been created, running this function will\n        minimize the chain and return the elementary step results from the final minimized chain.\n\n        Running this function will populate the `.chain_trajectory` object variable, which\n        contains the history of the chains minimized. Once it is completed, you can use\n        `.plot_opt_history()` to view the optimization over time.\n\n        Args:\n            self: initialized NEB object\n        Raises:\n            NoneConvergedException: If chain did not converge in alloted steps.\n        \"\"\"\n\n        nsteps = 1\n        nsteps_negative_grad_corr = 0\n\n        if self.parameters.preopt_with_xtb:\n            chain_previous = self._do_xtb_preopt(self.initial_chain)\n            self.chain_trajectory.append(chain_previous)\n\n            stop_early, elem_step_results = self._do_early_stop_check(\n                chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n        else:\n            chain_previous = self.initial_chain.copy()\n            self.chain_trajectory.append(chain_previous)\n        chain_previous._zero_velocity()\n\n        while nsteps &lt; self.parameters.max_steps + 1:\n            if nsteps &gt; 1:\n                stop_early, elem_step_results = self._check_early_stop(\n                    chain_previous)\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                if stop_early:\n                    return elem_step_results\n\n            new_chain = self.update_chain(chain=chain_previous)\n            max_rms_grad_val = np.amax(new_chain.rms_gperps)\n            ind_ts_guess = np.argmax(new_chain.energies)\n            ts_guess_grad = np.amax(\n                np.abs(new_chain.get_g_perps()[ind_ts_guess]))\n            converged = chain_converged(\n                chain_prev=chain_previous, chain_new=new_chain,\n                parameters=self.parameters)\n            if converged and self.parameters.v:\n                print(\"\\nConverged!\")\n\n            n_nodes_frozen = 0\n            for node in new_chain:\n                if node.converged:\n                    n_nodes_frozen += 1\n\n            grad_calls_made = len(new_chain) - n_nodes_frozen\n            self.grad_calls_made += grad_calls_made\n\n            grad_corr = new_chain._gradient_correlation(chain_previous)\n            if grad_corr &lt; 0:\n                nsteps_negative_grad_corr += 1\n            else:\n                nsteps_negative_grad_corr = 0\n\n            if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n                print(\"\\nstep size causing oscillations. decreasing by 50%\")\n                self.optimizer.timestep *= 0.5\n                nsteps_negative_grad_corr = 0\n\n            if self.parameters.v:\n\n                print(\n                    f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                        max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                            {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                                  {n_nodes_frozen} // {grad_corr}{' '*20}\", end=\"\\r\"\n                )\n                sys.stdout.flush()\n\n            self.chain_trajectory.append(new_chain)\n            self.gradient_trajectory.append(new_chain.gradients)\n\n            if converged:\n                if self.parameters.v:\n                    print(\"\\nChain converged!\")\n\n                elem_step_results = check_if_elem_step(new_chain)\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                self.optimized = new_chain\n                return elem_step_results\n\n            chain_previous = new_chain\n            nsteps += 1\n\n        new_chain = self.update_chain(chain=chain_previous)\n        if not chain_converged(chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters):\n            raise NoneConvergedException(\n                trajectory=self.chain_trajectory,\n                msg=f\"\\nChain did not converge at step {nsteps}\",\n                obj=self,\n            )\n\n    def update_chain(self, chain: Chain) -&gt; Chain:\n        grad_step = chain.gradients\n        new_chain = self.optimizer.optimize_step(\n            chain=chain, chain_gradients=grad_step)\n        return new_chain\n\n    def write_to_disk(self, fp: Path, write_history=True):\n        # write output chain\n        self.chain_trajectory[-1].write_to_disk(fp)\n\n        if write_history:\n            out_folder = fp.resolve().parent / (fp.stem + \"_history\")\n\n            if out_folder.exists():\n                shutil.rmtree(out_folder)\n\n            if not out_folder.exists():\n                out_folder.mkdir()\n\n            for i, chain in enumerate(self.chain_trajectory):\n                fp = out_folder / f\"traj_{i}.xyz\"\n                chain.write_to_disk(fp)\n\n    def plot_chain_distances(self):\n        distances = _calculate_chain_distances(self.chain_trajectory)\n\n        fs = 18\n        s = 8\n\n        f, ax = plt.subplots(figsize=(1.16*s, s))\n\n        plt.plot(distances, 'o-')\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylabel(\"Distance to previous chain\", fontsize=fs)\n        plt.xlabel(\"Chain id\", fontsize=fs)\n\n        plt.show()\n\n    def plot_grad_delta_mag_history(self):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i-1]\n            projs.append(prev_chain._gradient_delta_mags(chain))\n\n        plt.plot(projs)\n        plt.ylabel(\"NEB |\u2206gradient|\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        # plt.ylim(0,1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_projector_history(self, var='gradients'):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i-1]\n            if var == 'gradients':\n                projs.append(prev_chain._gradient_correlation(chain))\n            elif var == 'tangents':\n                projs.append(prev_chain._tangent_correlations(chain))\n            else:\n                raise ValueError(f\"Unrecognized var: {var}\")\n        plt.plot(projs)\n        plt.ylabel(f\"NEB {var} correlation\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylim(-1.1, 1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_opt_history(self, do_3d=False):\n\n        s = 8\n        fs = 18\n\n        if do_3d:\n            all_chains = self.chain_trajectory\n\n            ens = np.array([c.energies-c.energies[0] for c in all_chains])\n            all_integrated_path_lengths = np.array(\n                [c.integrated_path_length for c in all_chains])\n            opt_step = np.array(list(range(len(all_chains))))\n            s = 7\n            fs = 18\n            ax = plt.figure(figsize=(1.16*s, s)).add_subplot(projection='3d')\n\n            # Plot a sin curve using the x and y axes.\n            x = opt_step\n            ys = all_integrated_path_lengths\n            zs = ens\n            for i, (xind, y) in enumerate(zip(x, ys)):\n                if i &lt; len(ys) - 1:\n                    ax.plot([xind]*len(y), y, 'o-', zs=zs[i],\n                            color='gray', markersize=3, alpha=.1)\n                else:\n                    ax.plot([xind]*len(y), y, 'o-', zs=zs[i],\n                            color='blue', markersize=3)\n            ax.grid(False)\n\n            ax.set_xlabel('optimization step', fontsize=fs)\n            ax.set_ylabel('integrated path length', fontsize=fs)\n            ax.set_zlabel('energy (hartrees)', fontsize=fs)\n\n            # Customize the view angle so it's easier to see that the scatter points lie\n            # on the plane y=0\n            ax.view_init(elev=20., azim=-45)\n            plt.tight_layout()\n            plt.show()\n\n        else:\n            f, ax = plt.subplots(figsize=(1.16 * s, s))\n\n            for i, chain in enumerate(self.chain_trajectory):\n                if i == len(self.chain_trajectory) - 1:\n                    plt.plot(chain.integrated_path_length,\n                             chain.energies, \"o-\", alpha=1)\n                else:\n                    plt.plot(\n                        chain.integrated_path_length,\n                        chain.energies,\n                        \"o-\",\n                        alpha=0.1,\n                        color=\"gray\",\n                    )\n\n            plt.xlabel(\"Integrated path length\", fontsize=fs)\n\n            plt.ylabel(\"Energy (kcal/mol)\", fontsize=fs)\n            plt.xticks(fontsize=fs)\n            plt.yticks(fontsize=fs)\n            plt.show()\n\n    def plot_convergence_metrics(self, do_indiv=False):\n        ct = self.chain_trajectory\n\n        avg_rms_gperp = []\n        max_rms_gperp = []\n        avg_rms_g = []\n        barr_height = []\n        ts_gperp = []\n\n        for ind in range(1, len(ct)):\n            avg_rms_g.append(\n                sum(ct[ind].rms_gradients[1:-1]) / (len(ct[ind])-2))\n            avg_rms_gperp.append(\n                sum(ct[ind].rms_gperps[1:-1]) / (len(ct[ind])-2))\n            max_rms_gperp.append(max(ct[ind].rms_gperps))\n            barr_height.append(\n                abs(ct[ind].get_eA_chain() - ct[ind-1].get_eA_chain()))\n            ts_node_ind = ct[ind].energies.argmax()\n            ts_node_gperp = np.max(ct[ind].get_g_perps()[ts_node_ind])\n            ts_gperp.append(ts_node_gperp)\n\n        if do_indiv:\n            def plot_with_hline(data, label, y_hline, hline_label, hline_color, ylabel):\n                f, ax = plt.subplots()\n                plt.plot(data, label=label)\n                plt.ylabel(ylabel)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(y=y_hline, xmin=xmin, xmax=xmax,\n                          label=hline_label, linestyle='--', color=hline_color)\n                f.legend()\n                plt.show()\n\n            # Plot RMS Grad$_{\\perp}$\n            plot_with_hline(avg_rms_gperp, label='RMS Grad$_{\\perp}$',\n                            y_hline=self.parameters.rms_grad_thre,\n                            hline_label='rms_grad_thre', hline_color='blue',\n                            ylabel=\"Gradient data\")\n\n            # Plot Max RMS Grad$_{\\perp}$\n            plot_with_hline(max_rms_gperp, label='Max RMS Grad$_{\\perp}$',\n                            y_hline=self.parameters.max_rms_grad_thre,\n                            hline_label='max_rms_grad_thre', hline_color='orange',\n                            ylabel=\"Gradient data\")\n\n            # Plot TS gperp\n            plot_with_hline(ts_gperp, label='TS gperp',\n                            y_hline=self.parameters.ts_grad_thre,\n                            hline_label='ts_grad_thre', hline_color='green',\n                            ylabel=\"Gradient data\")\n\n            # Plot barrier height\n            plot_with_hline(barr_height, label='barr_height_delta',\n                            y_hline=self.parameters.barrier_thre,\n                            hline_label='barrier_thre', hline_color='purple',\n                            ylabel=\"Barrier height data\")\n\n        else:\n            # Define the data and parameters\n            data_list = [\n                (avg_rms_gperp, 'RMS Grad$_{\\perp}$',\n                 self.parameters.rms_grad_thre, 'rms_grad_thre', 'blue'),\n                (max_rms_gperp, 'Max RMS Grad$_{\\perp}$',\n                 self.parameters.max_rms_grad_thre, 'max_rms_grad_thre', 'orange'),\n                (ts_gperp, 'TS gperp', self.parameters.ts_grad_thre,\n                 'ts_grad_thre', 'green')\n            ]\n\n            # Create subplots\n            f, ax = plt.subplots()\n\n            # Plot the gradient data\n            for data, label, hline, hline_label, color in data_list:\n                ax.plot(data, label=label)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(y=hline, xmin=xmin, xmax=xmax,\n                          label=hline_label, linestyle='--', color=color)\n\n            # Set y-axis label for gradient data\n            ax.set_ylabel(\"Gradient data\")\n\n            # Create a second y-axis for barrier height data\n            ax2 = ax.twinx()\n            ax2.plot(barr_height, 'o--',\n                     label='barr_height_delta', color='purple')\n            ax2.set_ylabel(\"Barrier height data\")\n            ax2.hlines(y=self.parameters.barrier_thre, xmin=xmin, xmax=xmax,\n                       label='barrier_thre', linestyle='--', color='purple')\n\n            # Show legends and plot\n            f.legend(loc='upper left')\n            plt.show()\n\n    def read_from_disk(fp: Path, history_folder: Path = None,\n                       chain_parameters=ChainInputs(),\n                       neb_parameters=NEBInputs(),\n                       gi_parameters=GIInputs(),\n                       optimizer=VelocityProjectedOptimizer()):\n        if isinstance(fp, str):\n            fp = Path(fp)\n\n        if history_folder is None:\n            history_folder = fp.parent / (str(fp.stem) + \"_history\")\n\n        if not history_folder.exists():\n            raise ValueError(\"No history exists for this. Cannot load object.\")\n        else:\n            history_files = list(history_folder.glob(\"*.xyz\"))\n            history = [\n                Chain.from_xyz(\n                    history_folder / f\"traj_{i}.xyz\", parameters=chain_parameters\n                )\n                for i, _ in enumerate(history_files)\n            ]\n\n        n = NEB(\n            initial_chain=history[0],\n            parameters=neb_parameters,\n            optimized=history[-1],\n            chain_trajectory=history,\n            optimizer=optimizer\n        )\n        return n\n</code></pre>"},{"location":"neb/#neb_dynamics.NEB.NEB.optimize_chain","title":"<code>optimize_chain()</code>","text":"<p>Main function. After an NEB object has been created, running this function will minimize the chain and return the elementary step results from the final minimized chain.</p> <p>Running this function will populate the <code>.chain_trajectory</code> object variable, which contains the history of the chains minimized. Once it is completed, you can use <code>.plot_opt_history()</code> to view the optimization over time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>initialized NEB object</p> required <p>Raises:     NoneConvergedException: If chain did not converge in alloted steps.</p> Source code in <code>neb_dynamics/NEB.py</code> <pre><code>def optimize_chain(self) -&gt; ElemStepResults:\n    \"\"\"\n    Main function. After an NEB object has been created, running this function will\n    minimize the chain and return the elementary step results from the final minimized chain.\n\n    Running this function will populate the `.chain_trajectory` object variable, which\n    contains the history of the chains minimized. Once it is completed, you can use\n    `.plot_opt_history()` to view the optimization over time.\n\n    Args:\n        self: initialized NEB object\n    Raises:\n        NoneConvergedException: If chain did not converge in alloted steps.\n    \"\"\"\n\n    nsteps = 1\n    nsteps_negative_grad_corr = 0\n\n    if self.parameters.preopt_with_xtb:\n        chain_previous = self._do_xtb_preopt(self.initial_chain)\n        self.chain_trajectory.append(chain_previous)\n\n        stop_early, elem_step_results = self._do_early_stop_check(\n            chain_previous)\n        self.geom_grad_calls_made += elem_step_results.number_grad_calls\n        if stop_early:\n            return elem_step_results\n    else:\n        chain_previous = self.initial_chain.copy()\n        self.chain_trajectory.append(chain_previous)\n    chain_previous._zero_velocity()\n\n    while nsteps &lt; self.parameters.max_steps + 1:\n        if nsteps &gt; 1:\n            stop_early, elem_step_results = self._check_early_stop(\n                chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n\n        new_chain = self.update_chain(chain=chain_previous)\n        max_rms_grad_val = np.amax(new_chain.rms_gperps)\n        ind_ts_guess = np.argmax(new_chain.energies)\n        ts_guess_grad = np.amax(\n            np.abs(new_chain.get_g_perps()[ind_ts_guess]))\n        converged = chain_converged(\n            chain_prev=chain_previous, chain_new=new_chain,\n            parameters=self.parameters)\n        if converged and self.parameters.v:\n            print(\"\\nConverged!\")\n\n        n_nodes_frozen = 0\n        for node in new_chain:\n            if node.converged:\n                n_nodes_frozen += 1\n\n        grad_calls_made = len(new_chain) - n_nodes_frozen\n        self.grad_calls_made += grad_calls_made\n\n        grad_corr = new_chain._gradient_correlation(chain_previous)\n        if grad_corr &lt; 0:\n            nsteps_negative_grad_corr += 1\n        else:\n            nsteps_negative_grad_corr = 0\n\n        if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n            print(\"\\nstep size causing oscillations. decreasing by 50%\")\n            self.optimizer.timestep *= 0.5\n            nsteps_negative_grad_corr = 0\n\n        if self.parameters.v:\n\n            print(\n                f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                    max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                        {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                              {n_nodes_frozen} // {grad_corr}{' '*20}\", end=\"\\r\"\n            )\n            sys.stdout.flush()\n\n        self.chain_trajectory.append(new_chain)\n        self.gradient_trajectory.append(new_chain.gradients)\n\n        if converged:\n            if self.parameters.v:\n                print(\"\\nChain converged!\")\n\n            elem_step_results = check_if_elem_step(new_chain)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            self.optimized = new_chain\n            return elem_step_results\n\n        chain_previous = new_chain\n        nsteps += 1\n\n    new_chain = self.update_chain(chain=chain_previous)\n    if not chain_converged(chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters):\n        raise NoneConvergedException(\n            trajectory=self.chain_trajectory,\n            msg=f\"\\nChain did not converge at step {nsteps}\",\n            obj=self,\n        )\n</code></pre>"},{"location":"neb/#neb_dynamics.NEB.NEB.set_climbing_nodes","title":"<code>set_climbing_nodes(chain)</code>","text":"<p>Iterates through chain and sets the nodes that should climb.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>chain to set inputs for</p> required Source code in <code>neb_dynamics/NEB.py</code> <pre><code>def set_climbing_nodes(self, chain: Chain) -&gt; None:\n    \"\"\"Iterates through chain and sets the nodes that should climb.\n\n    Args:\n        chain: chain to set inputs for\n    \"\"\"\n    if self.parameters.climb:\n        inds_maxima = [chain.energies.argmax()]\n\n        if self.parameters.v &gt; 0:\n            print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n        for ind in inds_maxima:\n            chain[ind].do_climb = True\n</code></pre>"}]}