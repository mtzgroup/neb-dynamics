{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neb Dynamics","text":"<p>Hello</p>"},{"location":"neb/","title":"Neb","text":""},{"location":"neb/#neb_dynamics.NEB.NEB","title":"<code>NEB</code>  <code>dataclass</code>","text":"<p>Class for running, storing, and visualizing nudged elastic band minimizations. Main functions to use are: - self.optimize_chain() - self.plot_opt_history()</p> <p>Danger</p> <p>Colton said this sucks</p> Source code in <code>neb_dynamics/NEB.py</code> <pre><code>@dataclass\nclass NEB:\n    \"\"\"\n    Class for running, storing, and visualizing nudged elastic band minimizations.\n    Main functions to use are:\n    - self.optimize_chain()\n    - self.plot_opt_history()\n\n    !!! Danger\n        Colton said this sucks\n\n    \"\"\"\n    initial_chain: Chain\n    parameters: NEBInputs\n    optimizer: Optimizer\n\n    optimized: Chain = None\n    chain_trajectory: list[Chain] = field(default_factory=list)\n    gradient_trajectory: list[np.array] = field(default_factory=list)\n\n    def __post_init__(self):\n        self.n_steps_still_chain = 0\n        self.grad_calls_made = 0\n        self.geom_grad_calls_made = 0\n\n    def _reset_node_convergence(self, chain) -&gt; None:\n        for node in chain:\n            node.converged = False\n\n    def set_climbing_nodes(self, chain: Chain) -&gt; None:\n        \"\"\"Iterates through chain and sets the nodes that should climb.\n\n        Args:\n            chain: chain to set inputs for\n        \"\"\"\n        if self.parameters.climb:\n            inds_maxima = [chain.energies.argmax()]\n\n            if self.parameters.v &gt; 0:\n                print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n            for ind in inds_maxima:\n                chain[ind].do_climb = True\n\n    def _do_early_stop_check(self, chain: Chain) -&gt; Tuple[bool, ElemStepResults]:\n        \"\"\"\n        this function calls geometry minimizations to verify if\n        chain is an elementary step\n\n        Args:\n            chain (Chain): chain to check\n\n        Returns:\n            tuple(boolean, ElemStepResults) : boolean of whether\n                    to stop early, and an ElemStepResults objects\n        \"\"\"\n\n        elem_step_results = check_if_elem_step(chain)\n\n        if not elem_step_results.is_elem_step:\n            print(\"\\nStopped early because chain is not an elementary step.\")\n            print(\n                f\"Split chain based on: {elem_step_results.splitting_criterion}\")\n            self.optimized = chain\n            return True, elem_step_results\n\n        else:\n            self.n_steps_still_chain = 0\n            return False, elem_step_results\n\n    def _check_early_stop(self, chain: Chain):\n        \"\"\"\n        this function computes chain distances and checks gradient\n        values in order to decide whether the expensive minimization of\n        the chain should be done.\n        \"\"\"\n        # max_grad_val = chain.get_maximum_grad_magnitude()\n        # max_grad_val = np.linalg.norm(chain.get_g_perps())\n        ind_ts_guess = np.argmax(chain.energies)\n        ts_guess_grad = np.amax(np.abs(chain.get_g_perps()[ind_ts_guess]))\n\n        if ts_guess_grad &lt;= self.parameters.early_stop_force_thre:\n\n            new_params = self.parameters.copy()\n            new_params.early_stop_force_thre = 0.0\n            self.parameters = new_params\n\n            # going to set climbing nodes when checking early stop\n            if self.parameters.climb:\n                self.set_climbing_nodes(chain=chain)\n                self.parameters.climb = False  # no need to set climbing nodes again\n\n            stop_early, elem_step_results = self._do_early_stop_check(\n                chain)\n            return stop_early, elem_step_results\n\n        else:\n            return False, ElemStepResults(is_elem_step=None,\n                                          is_concave=None,\n                                          splitting_criterion=None,\n                                          minimization_results=[],\n                                          number_grad_calls=0)\n\n    # @Jan: This should be a more general function so that the\n    # lower level of theory can be whatever the user wants.\n    def _do_xtb_preopt(self, chain) -&gt; Chain:  #\n        \"\"\"\n        This function will loosely minimize an input chain using the GFN2-XTB method,\n        then return a new chain which can be used as an initial guess for a higher\n        level of theory calculation\n        \"\"\"\n\n        xtb_params = chain.parameters.copy()\n        xtb_params.node_class = Node3D\n        chain_traj = chain.to_trajectory()\n        xtb_chain = Chain.from_traj(chain_traj, parameters=xtb_params)\n        xtb_nbi = NEBInputs(tol=self.parameters.tol*10,\n                            v=True, preopt_with_xtb=False, max_steps=1000)\n\n        opt_xtb = VelocityProjectedOptimizer(timestep=1)\n        n = NEB(initial_chain=xtb_chain, parameters=xtb_nbi, optimizer=opt_xtb)\n        try:\n            _ = n.optimize_chain()\n            print(\n                f\"\\nConverged an xtb chain in {len(n.chain_trajectory)} steps\")\n        except Exception:\n            print(\n                f\"\\nCompleted {len(n.chain_trajectory)} xtb steps. Did not converge.\")\n\n        xtb_seed_tr = n.chain_trajectory[-1].to_trajectory()\n        xtb_seed_tr.update_tc_parameters(chain[0].tdstructure)\n\n        xtb_seed = Chain.from_traj(\n            xtb_seed_tr, parameters=chain.parameters.copy())\n        xtb_seed.gradients  # calling it to cache the values\n\n        return xtb_seed\n\n    def optimize_chain(self) -&gt; ElemStepResults:\n        \"\"\"\n        Main function. After an NEB object has been created, running this function will\n        minimize the chain and return the elementary step results from the final minimized chain.\n\n        Running this function will populate the `.chain_trajectory` object variable, which\n        contains the history of the chains minimized. Once it is completed, you can use\n        `.plot_opt_history()` to view the optimization over time.\n\n        Args:\n            self: initialized NEB object\n        Raises:\n            NoneConvergedException: If chain did not converge in alloted steps.\n        \"\"\"\n\n        nsteps = 1\n        nsteps_negative_grad_corr = 0\n\n        if self.parameters.preopt_with_xtb:\n            chain_previous = self._do_xtb_preopt(self.initial_chain)\n            self.chain_trajectory.append(chain_previous)\n\n            stop_early, elem_step_results = self._do_early_stop_check(\n                chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n        else:\n            chain_previous = self.initial_chain.copy()\n            self.chain_trajectory.append(chain_previous)\n        chain_previous._zero_velocity()\n\n        while nsteps &lt; self.parameters.max_steps + 1:\n            if nsteps &gt; 1:\n                stop_early, elem_step_results = self._check_early_stop(\n                    chain_previous)\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                if stop_early:\n                    return elem_step_results\n\n            new_chain = self.update_chain(chain=chain_previous)\n            max_rms_grad_val = np.amax(new_chain.rms_gperps)\n            ind_ts_guess = np.argmax(new_chain.energies)\n            ts_guess_grad = np.amax(\n                np.abs(new_chain.get_g_perps()[ind_ts_guess]))\n            converged = chain_converged(\n                chain_prev=chain_previous, chain_new=new_chain,\n                parameters=self.parameters)\n            if converged and self.parameters.v:\n                print(\"\\nConverged!\")\n\n            n_nodes_frozen = 0\n            for node in new_chain:\n                if node.converged:\n                    n_nodes_frozen += 1\n\n            grad_calls_made = len(new_chain) - n_nodes_frozen\n            self.grad_calls_made += grad_calls_made\n\n            grad_corr = new_chain._gradient_correlation(chain_previous)\n            if grad_corr &lt; 0:\n                nsteps_negative_grad_corr += 1\n            else:\n                nsteps_negative_grad_corr = 0\n\n            if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n                print(\"\\nstep size causing oscillations. decreasing by 50%\")\n                self.optimizer.timestep *= 0.5\n                nsteps_negative_grad_corr = 0\n\n            if self.parameters.v:\n\n                print(\n                    f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                        max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                            {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                                  {n_nodes_frozen} // {grad_corr}{' '*20}\", end=\"\\r\"\n                )\n                sys.stdout.flush()\n\n            self.chain_trajectory.append(new_chain)\n            self.gradient_trajectory.append(new_chain.gradients)\n\n            if converged:\n                if self.parameters.v:\n                    print(\"\\nChain converged!\")\n\n                elem_step_results = check_if_elem_step(new_chain)\n                self.geom_grad_calls_made += elem_step_results.number_grad_calls\n                self.optimized = new_chain\n                return elem_step_results\n\n            chain_previous = new_chain\n            nsteps += 1\n\n        new_chain = self.update_chain(chain=chain_previous)\n        if not chain_converged(chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters):\n            raise NoneConvergedException(\n                trajectory=self.chain_trajectory,\n                msg=f\"\\nChain did not converge at step {nsteps}\",\n                obj=self,\n            )\n\n    def update_chain(self, chain: Chain) -&gt; Chain:\n        grad_step = chain.gradients\n        new_chain = self.optimizer.optimize_step(\n            chain=chain, chain_gradients=grad_step)\n        return new_chain\n\n    def write_to_disk(self, fp: Path, write_history=True):\n        # write output chain\n        self.chain_trajectory[-1].write_to_disk(fp)\n\n        if write_history:\n            out_folder = fp.resolve().parent / (fp.stem + \"_history\")\n\n            if out_folder.exists():\n                shutil.rmtree(out_folder)\n\n            if not out_folder.exists():\n                out_folder.mkdir()\n\n            for i, chain in enumerate(self.chain_trajectory):\n                fp = out_folder / f\"traj_{i}.xyz\"\n                chain.write_to_disk(fp)\n\n    def plot_chain_distances(self):\n        distances = _calculate_chain_distances(self.chain_trajectory)\n\n        fs = 18\n        s = 8\n\n        f, ax = plt.subplots(figsize=(1.16*s, s))\n\n        plt.plot(distances, 'o-')\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylabel(\"Distance to previous chain\", fontsize=fs)\n        plt.xlabel(\"Chain id\", fontsize=fs)\n\n        plt.show()\n\n    def plot_grad_delta_mag_history(self):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i-1]\n            projs.append(prev_chain._gradient_delta_mags(chain))\n\n        plt.plot(projs)\n        plt.ylabel(\"NEB |\u2206gradient|\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        # plt.ylim(0,1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_projector_history(self, var='gradients'):\n        s = 8\n        fs = 18\n        f, ax = plt.subplots(figsize=(1.16 * s, s))\n        projs = []\n\n        for i, chain in enumerate(self.chain_trajectory):\n            if i == 0:\n                continue\n            prev_chain = self.chain_trajectory[i-1]\n            if var == 'gradients':\n                projs.append(prev_chain._gradient_correlation(chain))\n            elif var == 'tangents':\n                projs.append(prev_chain._tangent_correlations(chain))\n            else:\n                raise ValueError(f\"Unrecognized var: {var}\")\n        plt.plot(projs)\n        plt.ylabel(f\"NEB {var} correlation\", fontsize=fs)\n        plt.yticks(fontsize=fs)\n        plt.xticks(fontsize=fs)\n        plt.ylim(-1.1, 1.1)\n        plt.xlabel(\"Optimization step\", fontsize=fs)\n        plt.show()\n\n    def plot_opt_history(self, do_3d=False):\n\n        s = 8\n        fs = 18\n\n        if do_3d:\n            all_chains = self.chain_trajectory\n\n            ens = np.array([c.energies-c.energies[0] for c in all_chains])\n            all_integrated_path_lengths = np.array(\n                [c.integrated_path_length for c in all_chains])\n            opt_step = np.array(list(range(len(all_chains))))\n            s = 7\n            fs = 18\n            ax = plt.figure(figsize=(1.16*s, s)).add_subplot(projection='3d')\n\n            # Plot a sin curve using the x and y axes.\n            x = opt_step\n            ys = all_integrated_path_lengths\n            zs = ens\n            for i, (xind, y) in enumerate(zip(x, ys)):\n                if i &lt; len(ys) - 1:\n                    ax.plot([xind]*len(y), y, 'o-', zs=zs[i],\n                            color='gray', markersize=3, alpha=.1)\n                else:\n                    ax.plot([xind]*len(y), y, 'o-', zs=zs[i],\n                            color='blue', markersize=3)\n            ax.grid(False)\n\n            ax.set_xlabel('optimization step', fontsize=fs)\n            ax.set_ylabel('integrated path length', fontsize=fs)\n            ax.set_zlabel('energy (hartrees)', fontsize=fs)\n\n            # Customize the view angle so it's easier to see that the scatter points lie\n            # on the plane y=0\n            ax.view_init(elev=20., azim=-45)\n            plt.tight_layout()\n            plt.show()\n\n        else:\n            f, ax = plt.subplots(figsize=(1.16 * s, s))\n\n            for i, chain in enumerate(self.chain_trajectory):\n                if i == len(self.chain_trajectory) - 1:\n                    plt.plot(chain.integrated_path_length,\n                             chain.energies, \"o-\", alpha=1)\n                else:\n                    plt.plot(\n                        chain.integrated_path_length,\n                        chain.energies,\n                        \"o-\",\n                        alpha=0.1,\n                        color=\"gray\",\n                    )\n\n            plt.xlabel(\"Integrated path length\", fontsize=fs)\n\n            plt.ylabel(\"Energy (kcal/mol)\", fontsize=fs)\n            plt.xticks(fontsize=fs)\n            plt.yticks(fontsize=fs)\n            plt.show()\n\n    def plot_convergence_metrics(self, do_indiv=False):\n        ct = self.chain_trajectory\n\n        avg_rms_gperp = []\n        max_rms_gperp = []\n        avg_rms_g = []\n        barr_height = []\n        ts_gperp = []\n\n        for ind in range(1, len(ct)):\n            avg_rms_g.append(\n                sum(ct[ind].rms_gradients[1:-1]) / (len(ct[ind])-2))\n            avg_rms_gperp.append(\n                sum(ct[ind].rms_gperps[1:-1]) / (len(ct[ind])-2))\n            max_rms_gperp.append(max(ct[ind].rms_gperps))\n            barr_height.append(\n                abs(ct[ind].get_eA_chain() - ct[ind-1].get_eA_chain()))\n            ts_node_ind = ct[ind].energies.argmax()\n            ts_node_gperp = np.max(ct[ind].get_g_perps()[ts_node_ind])\n            ts_gperp.append(ts_node_gperp)\n\n        if do_indiv:\n            def plot_with_hline(data, label, y_hline, hline_label, hline_color, ylabel):\n                f, ax = plt.subplots()\n                plt.plot(data, label=label)\n                plt.ylabel(ylabel)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(y=y_hline, xmin=xmin, xmax=xmax,\n                          label=hline_label, linestyle='--', color=hline_color)\n                f.legend()\n                plt.show()\n\n            # Plot RMS Grad$_{\\perp}$\n            plot_with_hline(avg_rms_gperp, label='RMS Grad$_{\\perp}$',\n                            y_hline=self.parameters.rms_grad_thre,\n                            hline_label='rms_grad_thre', hline_color='blue',\n                            ylabel=\"Gradient data\")\n\n            # Plot Max RMS Grad$_{\\perp}$\n            plot_with_hline(max_rms_gperp, label='Max RMS Grad$_{\\perp}$',\n                            y_hline=self.parameters.max_rms_grad_thre,\n                            hline_label='max_rms_grad_thre', hline_color='orange',\n                            ylabel=\"Gradient data\")\n\n            # Plot TS gperp\n            plot_with_hline(ts_gperp, label='TS gperp',\n                            y_hline=self.parameters.ts_grad_thre,\n                            hline_label='ts_grad_thre', hline_color='green',\n                            ylabel=\"Gradient data\")\n\n            # Plot barrier height\n            plot_with_hline(barr_height, label='barr_height_delta',\n                            y_hline=self.parameters.barrier_thre,\n                            hline_label='barrier_thre', hline_color='purple',\n                            ylabel=\"Barrier height data\")\n\n        else:\n            # Define the data and parameters\n            data_list = [\n                (avg_rms_gperp, 'RMS Grad$_{\\perp}$',\n                 self.parameters.rms_grad_thre, 'rms_grad_thre', 'blue'),\n                (max_rms_gperp, 'Max RMS Grad$_{\\perp}$',\n                 self.parameters.max_rms_grad_thre, 'max_rms_grad_thre', 'orange'),\n                (ts_gperp, 'TS gperp', self.parameters.ts_grad_thre,\n                 'ts_grad_thre', 'green')\n            ]\n\n            # Create subplots\n            f, ax = plt.subplots()\n\n            # Plot the gradient data\n            for data, label, hline, hline_label, color in data_list:\n                ax.plot(data, label=label)\n                xmin, xmax = ax.get_xlim()\n                ax.hlines(y=hline, xmin=xmin, xmax=xmax,\n                          label=hline_label, linestyle='--', color=color)\n\n            # Set y-axis label for gradient data\n            ax.set_ylabel(\"Gradient data\")\n\n            # Create a second y-axis for barrier height data\n            ax2 = ax.twinx()\n            ax2.plot(barr_height, 'o--',\n                     label='barr_height_delta', color='purple')\n            ax2.set_ylabel(\"Barrier height data\")\n            ax2.hlines(y=self.parameters.barrier_thre, xmin=xmin, xmax=xmax,\n                       label='barrier_thre', linestyle='--', color='purple')\n\n            # Show legends and plot\n            f.legend(loc='upper left')\n            plt.show()\n\n    def read_from_disk(fp: Path, history_folder: Path = None,\n                       chain_parameters=ChainInputs(),\n                       neb_parameters=NEBInputs(),\n                       gi_parameters=GIInputs(),\n                       optimizer=VelocityProjectedOptimizer()):\n        if isinstance(fp, str):\n            fp = Path(fp)\n\n        if history_folder is None:\n            history_folder = fp.parent / (str(fp.stem) + \"_history\")\n\n        if not history_folder.exists():\n            raise ValueError(\"No history exists for this. Cannot load object.\")\n        else:\n            history_files = list(history_folder.glob(\"*.xyz\"))\n            history = [\n                Chain.from_xyz(\n                    history_folder / f\"traj_{i}.xyz\", parameters=chain_parameters\n                )\n                for i, _ in enumerate(history_files)\n            ]\n\n        n = NEB(\n            initial_chain=history[0],\n            parameters=neb_parameters,\n            optimized=history[-1],\n            chain_trajectory=history,\n            optimizer=optimizer\n        )\n        return n\n</code></pre>"},{"location":"neb/#neb_dynamics.NEB.NEB.optimize_chain","title":"<code>optimize_chain()</code>","text":"<p>Main function. After an NEB object has been created, running this function will minimize the chain and return the elementary step results from the final minimized chain.</p> <p>Running this function will populate the <code>.chain_trajectory</code> object variable, which contains the history of the chains minimized. Once it is completed, you can use <code>.plot_opt_history()</code> to view the optimization over time.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>initialized NEB object</p> required <p>Raises:     NoneConvergedException: If chain did not converge in alloted steps.</p> Source code in <code>neb_dynamics/NEB.py</code> <pre><code>def optimize_chain(self) -&gt; ElemStepResults:\n    \"\"\"\n    Main function. After an NEB object has been created, running this function will\n    minimize the chain and return the elementary step results from the final minimized chain.\n\n    Running this function will populate the `.chain_trajectory` object variable, which\n    contains the history of the chains minimized. Once it is completed, you can use\n    `.plot_opt_history()` to view the optimization over time.\n\n    Args:\n        self: initialized NEB object\n    Raises:\n        NoneConvergedException: If chain did not converge in alloted steps.\n    \"\"\"\n\n    nsteps = 1\n    nsteps_negative_grad_corr = 0\n\n    if self.parameters.preopt_with_xtb:\n        chain_previous = self._do_xtb_preopt(self.initial_chain)\n        self.chain_trajectory.append(chain_previous)\n\n        stop_early, elem_step_results = self._do_early_stop_check(\n            chain_previous)\n        self.geom_grad_calls_made += elem_step_results.number_grad_calls\n        if stop_early:\n            return elem_step_results\n    else:\n        chain_previous = self.initial_chain.copy()\n        self.chain_trajectory.append(chain_previous)\n    chain_previous._zero_velocity()\n\n    while nsteps &lt; self.parameters.max_steps + 1:\n        if nsteps &gt; 1:\n            stop_early, elem_step_results = self._check_early_stop(\n                chain_previous)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            if stop_early:\n                return elem_step_results\n\n        new_chain = self.update_chain(chain=chain_previous)\n        max_rms_grad_val = np.amax(new_chain.rms_gperps)\n        ind_ts_guess = np.argmax(new_chain.energies)\n        ts_guess_grad = np.amax(\n            np.abs(new_chain.get_g_perps()[ind_ts_guess]))\n        converged = chain_converged(\n            chain_prev=chain_previous, chain_new=new_chain,\n            parameters=self.parameters)\n        if converged and self.parameters.v:\n            print(\"\\nConverged!\")\n\n        n_nodes_frozen = 0\n        for node in new_chain:\n            if node.converged:\n                n_nodes_frozen += 1\n\n        grad_calls_made = len(new_chain) - n_nodes_frozen\n        self.grad_calls_made += grad_calls_made\n\n        grad_corr = new_chain._gradient_correlation(chain_previous)\n        if grad_corr &lt; 0:\n            nsteps_negative_grad_corr += 1\n        else:\n            nsteps_negative_grad_corr = 0\n\n        if nsteps_negative_grad_corr &gt;= self.parameters.negative_steps_thre:\n            print(\"\\nstep size causing oscillations. decreasing by 50%\")\n            self.optimizer.timestep *= 0.5\n            nsteps_negative_grad_corr = 0\n\n        if self.parameters.v:\n\n            print(\n                f\"step {nsteps} // argmax(|TS gperp|) {np.amax(np.abs(ts_guess_grad))} // \\\n                    max rms grad {max_rms_grad_val} // armax(|TS_triplet_gsprings|) \\\n                        {new_chain.ts_triplet_gspring_infnorm} // nodes_frozen\\\n                              {n_nodes_frozen} // {grad_corr}{' '*20}\", end=\"\\r\"\n            )\n            sys.stdout.flush()\n\n        self.chain_trajectory.append(new_chain)\n        self.gradient_trajectory.append(new_chain.gradients)\n\n        if converged:\n            if self.parameters.v:\n                print(\"\\nChain converged!\")\n\n            elem_step_results = check_if_elem_step(new_chain)\n            self.geom_grad_calls_made += elem_step_results.number_grad_calls\n            self.optimized = new_chain\n            return elem_step_results\n\n        chain_previous = new_chain\n        nsteps += 1\n\n    new_chain = self.update_chain(chain=chain_previous)\n    if not chain_converged(chain_prev=chain_previous, chain_new=new_chain, parameters=self.parameters):\n        raise NoneConvergedException(\n            trajectory=self.chain_trajectory,\n            msg=f\"\\nChain did not converge at step {nsteps}\",\n            obj=self,\n        )\n</code></pre>"},{"location":"neb/#neb_dynamics.NEB.NEB.set_climbing_nodes","title":"<code>set_climbing_nodes(chain)</code>","text":"<p>Iterates through chain and sets the nodes that should climb.</p> <p>Parameters:</p> Name Type Description Default <code>chain</code> <code>Chain</code> <p>chain to set inputs for</p> required Source code in <code>neb_dynamics/NEB.py</code> <pre><code>def set_climbing_nodes(self, chain: Chain) -&gt; None:\n    \"\"\"Iterates through chain and sets the nodes that should climb.\n\n    Args:\n        chain: chain to set inputs for\n    \"\"\"\n    if self.parameters.climb:\n        inds_maxima = [chain.energies.argmax()]\n\n        if self.parameters.v &gt; 0:\n            print(f\"\\n-----&gt;Setting {len(inds_maxima)} nodes to climb\\n\")\n\n        for ind in inds_maxima:\n            chain[ind].do_climb = True\n</code></pre>"}]}